<!-- 
    
    DECOR schema
    Copyright (C) 2009-2018 Dr. Kai U. Heitmann
    
    This program is free software; you can redistribute it and/or modify it under the terms 
    of the GNU General Public License as published by the Free Software Foundation; 
    either version 3 of the License, or (at your option) any later version.
    
    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
    without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    See the GNU General Public License for more details.
    
    See http://www.gnu.org/licenses/gpl.html
    
-->
<xs:schema xmlns:xforms="http://www.w3.org/2002/xforms" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:sch="http://purl.oclc.org/dsdl/schematron" xmlns:fhir="http://hl7.org/fhir" xmlns:sqf="http://www.schematron-quickfix.com/validator/process" elementFormDefault="qualified">

    <!-- include DECOR datatype defintions -->
    <xs:include schemaLocation="DECOR-datatypes.xsd"/>

    <!-- this is the root element of any decor main file -->
    <xs:element name="decor">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Unique Ids</sch:title>
                    <sch:rule context="datasets/dataset//concept[not(ancestor::history)][not(parent::conceptList)][@id]">
                        <sch:let name="locationContext" value="concat(' | Location &lt;concept ', string-join(for $att in ancestor-or-self::concept[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:let name="currentId" value="@id"/>
                        <sch:let name="currentEffectiveDate" value="@effectiveDate"/>
                        <sch:let name="allCurrentIdEffectiveDates" value="//datasets/dataset//concept[@id=$currentId][@effectiveDate=$currentEffectiveDate][not(ancestor::history | parent::conceptList)]"/>
                        <sch:let name="allCurrentIds" value="//datasets/dataset//concept[@id=$currentId][not(ancestor::history|parent::conceptList)]"/>
                        <sch:assert role="error" test="if (@effectiveDate) then (count($allCurrentIdEffectiveDates)=1) else (count($allCurrentIds)=1)"
                            >ERROR: The <sch:name/>/@id '<sch:value-of select="$currentId"/>' SHALL be unique.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                    <sch:rule context="datasets/dataset//concept[not(ancestor::history)]/valueDomain/conceptList[@id]">
                        <sch:let name="locationContext" value="concat(' | Location &lt;concept ', string-join(for $att in ancestor-or-self::concept[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:let name="currentId" value="@id"/>
                        <sch:let name="currentEffectiveDate" value="@effectiveDate"/>
                        <sch:let name="allCurrentIdEffectiveDates" value="//datasets/dataset//concept[not(ancestor::history | parent::conceptList)]/valueDomain/conceptList[@id = $currentId]"/>
                        <sch:let name="allCurrentIds" value="//datasets/dataset//concept[not(ancestor::history | parent::conceptList)]/valueDomain/conceptList[@id = $currentId]"/>
                        <sch:assert role="error" test="if (ancestor::decor/@versionDate) then (true()) else if (@effectiveDate) then (count($allCurrentIdEffectiveDates)=1) else (count($allCurrentIds)=1)"
                            >ERROR: The <sch:name/>/@id '<sch:value-of select="$currentId"/>' SHALL be unique.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="1" maxOccurs="1" ref="project">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Projectinformatie</xforms:label>
                            <xforms:label xml:lang="en-US">Project Information</xforms:label>
                            <xforms:label xml:lang="de-DE">Informationen zum Projekt</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Projectinformatie</xs:documentation>
                        <xs:documentation xml:lang="en-US">Project Information</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Informationen zum Projekt</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element minOccurs="1" maxOccurs="1" ref="datasets">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Datasetdefinitie</xforms:label>
                            <xforms:label xml:lang="en-US">Data Set Definition</xforms:label>
                            <xforms:label xml:lang="de-DE">Data Set Definition</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Data Set Definitie</xs:documentation>
                        <xs:documentation xml:lang="en-US">Data Set Definition</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Data Set Definition</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element minOccurs="1" maxOccurs="1" ref="scenarios">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Scenariodefinitie</xforms:label>
                            <xforms:label xml:lang="en-US">Scenario Definition</xforms:label>
                            <xforms:label xml:lang="de-DE">Scenario Definition</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Scenariodefinitie, inclusief actoren, transacties, modellen, cardinaliteiten en conformancestatements</xs:documentation>
                        <xs:documentation xml:lang="en-US">Scenario Definition, with actors, transactions, models, cardinalities, conformance statements</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Scenario Definition, mit Aktoren, Transaktionen, Modellem, Kardinalitäten, Konformitätsangaben</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- identifiers -->
                <xs:element minOccurs="1" maxOccurs="1" ref="ids">
                    <xs:annotation>
                        <xs:appinfo>
                            <sch:pattern>
                                <sch:title>Validate Ids</sch:title>
                                <sch:let name="allTypes" value="tokenize('DS,DE,SC,TR,CS,IS,AC,CL,EL,TM,VS,RL,TX,SX,EX,QX,CM',',')"/>
                                <sch:let name="allExtensions" value="tokenize('1,2,3,4,5,6,7,8,9,10,11,16,17,18,19,20,21',',')"/>
                                
                                <sch:let name="allTypesCount" value="count($allTypes)"/>
                                <sch:rule context="ids">
                                    <sch:let name="locationContext" value="concat(' | Location &lt;ids ','/&gt;')"/>
                                    
                                    <sch:let name="idsBaseIdTypes" value="count(distinct-values(baseId/@type))"/>
                                    <sch:let name="idsDefaultBaseIdTypes" value="count(distinct-values(defaultBaseId/@type))"/>
                                    <sch:let name="idsBaseIdTypesMissing" value="normalize-space(string-join(for $type in $allTypes return (if (not(baseId[@type=$type])) then (concat($type,' ')) else ('')),''))"/>
                                    <sch:let name="idsDefaultBaseIdTypesMissing" value="normalize-space(string-join(for $type in $allTypes return (if (not(defaultBaseId[@type=$type])) then (concat($type,' ')) else ('')),''))"/>
                                    <sch:assert role="warning" test="$idsBaseIdTypes ge $allTypesCount" sqf:fix="addMissingBaseIds"
                                        >WARNING: Project SHOULD define a baseId for every possible type. Every missing type might lead to unexpected results. Expected '<sch:value-of select="$allTypesCount"/>', found '<sch:value-of select="$idsBaseIdTypes"/>'. Missing '<sch:value-of select="$idsBaseIdTypesMissing"/>'.<sch:value-of select="$locationContext"/></sch:assert>
                                    <sch:assert role="warning" test="$idsDefaultBaseIdTypes ge $allTypesCount" sqf:fix="addMissingDefaultBaseIds"
                                        >WARNING: Project SHOULD define a defaultBaseId for every possible type. Every missing type might lead to unexpected results. Expected '<sch:value-of select="$allTypesCount"/>', found '<sch:value-of select="$idsDefaultBaseIdTypes"/>'. Missing '<sch:value-of select="$idsDefaultBaseIdTypesMissing"/>'.<sch:value-of select="$locationContext"/></sch:assert>
                                </sch:rule>
                            </sch:pattern>
                        </xs:appinfo>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Gebruikte identificaties</xforms:label>
                            <xforms:label xml:lang="en-US">Identifiers used</xforms:label>
                            <xforms:label xml:lang="de-DE">Genutzte Identifikatoren</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Gebruikte identificaties, bedoeld voor weergavedoeleinden</xs:documentation>
                        <xs:documentation xml:lang="en-US">Identifiers used, rendering only</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Genutzte Identifikatoren, nur zur Anzeige</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- terminology, e.g. value sets -->
                <xs:element minOccurs="1" maxOccurs="1" ref="terminology">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Terminologische definities</xforms:label>
                            <xforms:label xml:lang="en-US">Terminology definitions</xforms:label>
                            <xforms:label xml:lang="de-DE">Terminologische Definitionen</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Terminologische definities</xs:documentation>
                        <xs:documentation xml:lang="en-US">Terminology definitions</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Terminologische Definitionen</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- rules -->
                <xs:element minOccurs="1" maxOccurs="1" ref="rules">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Regeldefinities</xforms:label>
                            <xforms:label xml:lang="en-US">Rules definitions</xforms:label>
                            <xforms:label xml:lang="de-DE">Regeldefinitionen</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Regeldefinities</xs:documentation>
                        <xs:documentation xml:lang="en-US">Rules definitions</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Regeldefinitionen</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- issues -->
                <xs:element minOccurs="1" maxOccurs="1" ref="issues">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Issuelijst</xforms:label>
                            <xforms:label xml:lang="en-US">Issue list</xforms:label>
                            <xforms:label xml:lang="de-DE">Problemliste</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Issuelijst</xs:documentation>
                        <xs:documentation xml:lang="en-US">Issue list</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Problemliste</xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="repository" type="xs:boolean" use="optional">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">DECOR-project is een (building block) repository (BBR)</xforms:label>
                        <xforms:label xml:lang="en-US">DECOR project is a (building block) repository (BBR)</xforms:label>
                        <xforms:label xml:lang="de-DE">DECOR-Projekt ist ein (Building Block) Repository (BBR)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Indication whether this DECOR project is a (building block) repository (BBR)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="private" type="xs:boolean" use="optional">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">DECOR-project is privé</xforms:label>
                        <xforms:label xml:lang="en-US">DECOR project is private</xforms:label>
                        <xforms:label xml:lang="de-DE">DECOR-Projekt ist privat</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Indication whether this DECOR project is private, i.e. should NOT be included in searches from external.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="release" type="SmallNonNegativeInteger" fixed="1000" use="optional">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">DECOR-project release nummer</xforms:label>
                        <xforms:label xml:lang="en-US">DECOR project release number</xforms:label>
                        <xforms:label xml:lang="de-DE">DECOR-Projekt Release Nummer</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Release number (dddd) of the DECOR project file, for conversion detection beteeen releases later</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- Only relevant after compilation -->
            <xs:attributeGroup ref="DecorCompilationAttributes"/>
            
            <xs:anyAttribute namespace="##other" processContents="skip">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Contains dummy attributes that force xmlns declarations for templates</xs:documentation>
                </xs:annotation>
            </xs:anyAttribute>
        </xs:complexType>
    </xs:element>
    
    <!-- 
    
        project
        
    -->
    <xs:element name="project">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="copyright" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element ref="author" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="reference" minOccurs="0" maxOccurs="1"/>
                <xs:element ref="restURI" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="defaultElementNamespace" minOccurs="0" maxOccurs="1"/>
                <xs:element ref="contact" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="buildingBlockRepository" minOccurs="0" maxOccurs="unbounded"/>
                <xs:choice maxOccurs="unbounded">
                    <xs:element name="version" type="ProjectHistory" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="release" type="ProjectRelease" minOccurs="0" maxOccurs="unbounded"/>
                </xs:choice>
            </xs:sequence>
            <xs:attribute name="id" type="Oid" use="required"/>
            <xs:attribute name="prefix" type="ShortDescriptiveName" use="required"/>
            <xs:attribute name="defaultLanguage" type="LanguageCode" use="required"/>
            <xs:attribute name="experimental" type="xs:boolean" default="false" use="optional">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">experimental</xforms:label>
                        <xforms:label xml:lang="nl-NL">voor testdoeleinden</xforms:label>
                        <xforms:label xml:lang="de-DE">für Testzwecke</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">DECOR project is for testing purposes, not real usage</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
        <xs:unique name="project-name-unique">
            <xs:selector xpath="name"/>
            <xs:field xpath="@language"/>
        </xs:unique>
        <xs:unique name="project-desc-unique">
            <xs:selector xpath="desc"/>
            <xs:field xpath="@language"/>
        </xs:unique>
        <xs:unique name="project-author-unique">
            <xs:selector xpath="author"/>
            <xs:field xpath="@id"/>
        </xs:unique>
        <xs:unique name="project-buildingBlockRepository-unique">
            <xs:selector xpath="buildingBlockRepository"/>
            <xs:field xpath="@url"/>
            <xs:field xpath="@ident"/>
        </xs:unique>
    </xs:element>
    <xs:element name="author">
        <xs:complexType mixed="true">
            <xs:attribute name="id" type="xs:positiveInteger" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">author's id, shall be a shorthand id per project, e.g. "1"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="username" type="NonEmptyString" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">username, must be the same as the corresponding Exist-DB login name</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="email" type="EmailType" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">User's email address</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="notifier" type="NotifierOnOff" use="optional" default="on">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Specifies whether the automatic notifier system (if activated) should notify this author about changes of any project issue. Default is "on"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute ref="effectiveDate" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Date the author became effective. On a project author this the date he became a project author. On an issue event it is the date he became author of this event.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="copyright">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate Copyright</sch:title>
                        <sch:rule context="copyright[ancestor::project]">
                            <sch:assert role="error" test="string-length(@years)&gt;0"
                                >ERROR: At least one year SHALL be present in copyright by <sch:value-of select="@by"/></sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:sequence>
                <xs:element ref="addrLine" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="years" type="YearRanges" use="required"/>
            <xs:attribute name="by" type="ShortDescriptiveName"/>
            <xs:attribute name="logo" type="Uri"/>
            <xs:attribute name="type" use="optional" type="CopyrightType" default="author"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="CopyrightType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Structured Copyright type. Determines the way that the copyright holder contributed to the project/building block repository contents</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="author">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Auteur</xforms:label>
                        <xforms:label xml:lang="en-US">Author</xforms:label>
                        <xforms:label xml:lang="de-DE">Autor</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="contributor">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Contributor</xforms:label>
                        <xforms:label xml:lang="en-US">Contributor</xforms:label>
                        <xforms:label xml:lang="de-DE">Mitwirkender</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="reviewer">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Reviewer</xforms:label>
                        <xforms:label xml:lang="en-US">Reviewer</xforms:label>
                        <xforms:label xml:lang="de-DE">Rezensent</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="addrLine">
        <xs:complexType mixed="true">
            <xs:sequence/>
            <xs:attribute name="type" type="AddressLineType" use="optional"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="reference">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate Reference</sch:title>
                        <sch:rule context="//project/reference">
                            <sch:let name="locationContext" value="concat(' | Location &lt;reference ', string-join(for $att in @* return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                            <!--
                            <sch:assert role="error" test="not(@url) or substring(@url, string-length(@url), 1)='/'"
                                >ERROR: Project publication location (reference) URL '<sch:value-of select="@url"/>' SHALL end with "/".<sch:value-of select="$locationContext"/></sch:assert>
                            -->
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:attribute name="url" type="Uri"/>
            <xs:attribute name="logo" type="Uri"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="restURI">
        <xs:annotation>
            <xs:appinfo>
                <xforms:label xml:lang="nl-NL">RESTful service</xforms:label>
                <xforms:label xml:lang="en-US">RESTful Service</xforms:label>
                <xforms:label xml:lang="de-DE">RESTful Service</xforms:label>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">End Point for RESTful services. Examples are FHIR End Points, and DECOR services</xs:documentation>
        </xs:annotation>
        <xs:complexType mixed="true">
            <xs:attribute name="for" type="DecorAndOtherObjectTypes" use="required"/>
            <xs:attribute name="format" type="DecorAndOtherObjectFormats" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="defaultElementNamespace">
        <xs:annotation>
            <xs:appinfo>
                <xforms:label xml:lang="nl-NL">Standaard template-element namespace</xforms:label>
                <xforms:label xml:lang="en-US">Default Template Element Namespace</xforms:label>
                <xforms:label xml:lang="de-DE">Default Template Element Namespace</xforms:label>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">The default namespace prefix for all template element name definitions</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence/>
            <xs:attribute name="ns" type="NamespacePrefix" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="buildingBlockRepository">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate buildingBlockRepository</sch:title>
                    <sch:rule context="//project/buildingBlockRepository">
                        <sch:let name="locationContext" value="concat(' | Location &lt;buildingBlockRepository ', string-join(for $att in @* return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:assert role="error" test="substring(@url, string-length(@url), 1)='/'" sqf:fix="addSlashToURL"
                            >ERROR: Project repository URL "<sch:value-of select="@url"/>" SHALL end with "/".<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@ident) or substring(@ident, string-length(@ident), 1)='-'" sqf:fix="addHyphenToIdent"
                            >ERROR: Project repository ident "<sch:value-of select="@ident"/>" SHALL end with "-".<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not((not(@format) or @format='decor') and not(@ident))"
                            >ERROR: Project repository ident SHALL have a value when @format = 'decor' (this is the default value).<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:assert role="error" test="not(@format = 'fhir') or @ident"
                            >ERROR: Project repository ident SHALL have a value when @format = 'fhir'.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
            <xs:appinfo>
                <xforms:label xml:lang="nl-NL">Repository referentie</xforms:label>
                <xforms:label xml:lang="en-US">Repository reference</xforms:label>
                <xforms:label xml:lang="de-DE">Repository Referenz</xforms:label>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">ART-DECOR repository reference</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence/>
            <xs:attribute name="url" type="Uri" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">ART-DECOR repository URI directly pointing to the services, e.g. "http://art-decor.org/services/"; ends with "/"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ident" type="NonEmptyString" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">ART-DECOR repository identification string (prefix), e.g. "ad1bbr-"; ends with "-"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="licenseKey" type="NonEmptyString" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">For future use</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="format" type="BuildingBlockRepositoryFormat" use="optional" default="decor">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Determines the format of building blocks on the end point</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute ref="displayName" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A human-friendly name of the repository.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    
    <xs:simpleType name="BuildingBlockRepositoryFormat">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Decor Object Types. Note: should you ever change list, please also see schematron check with name="Validate Ids".</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="decor">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">DECOR</xforms:label>
                        <xforms:label xml:lang="en-US">DECOR</xforms:label>
                        <xforms:label xml:lang="de-DE">DECOR</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">DECOR building blocks</xs:documentation>
                    <xs:documentation xml:lang="en-US">DECOR building blocks</xs:documentation>
                    <xs:documentation xml:lang="de-DE">DECOR building blocks</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="fhir">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7 FHIR</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 FHIR</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 FHIR</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">HL7 FHIR® bouwstenen, compatibiliteit met versie en andere capaciteiten zoals welke resources deze levert, vast te stellen op basis van de Conformance profile op het endpoint</xs:documentation>
                    <xs:documentation xml:lang="en-US">HL7 FHIR® building blocks, compatibility with version and other capabilities such as which resources it serves to be determined based on the Conformance profile on the endpoint</xs:documentation>
                    <xs:documentation xml:lang="de-DE">HL7 FHIR® building blocks, compatibility with version and other capabilities such as which resources it serves to be determined based on the Conformance profile on the endpoint</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    
    <!-- http://www.w3.org/TR/REC-xml/#NT-Name - didn't know how to code hex chars in pattern or I would have -->
    <xs:simpleType name="NamespacePrefix">
        <xs:restriction base="xs:string">
            <xs:pattern value="[^\s:\.0-9-][^\s:]*:"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="contact">
        <xs:complexType>
            <xs:attribute name="email" type="EmailType"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="DecorAndOtherObjectTypes">
        <xs:union memberTypes="DecorObjectType FhirObjectType"/>
    </xs:simpleType>
    <xs:simpleType name="FhirObjectType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">HL7 FHIR®© Object Types. Note: should you ever change list, please also see schematron check with name="Validate Ids". http://hl7.org/fhir/</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="FHIR">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">FHIR</xforms:label>
                        <xforms:label xml:lang="en-US">FHIR</xforms:label>
                        <xforms:label xml:lang="de-DE">FHIR</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">FHIR</xs:documentation>
                    <xs:documentation xml:lang="en-US">FHIR</xs:documentation>
                    <xs:documentation xml:lang="de-DE">FHIR</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="DecorObjectType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Decor Object Types. Note: should you ever change list, please also see schematron check with name="Validate Ids".</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="DS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Dataset</xforms:label>
                        <xforms:label xml:lang="en-US">Data set</xforms:label>
                        <xforms:label xml:lang="de-DE">Datensatz</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">Dataset</xs:documentation>
                    <xs:documentation xml:lang="en-US">Data set</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Datensatz</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="DE">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Dataelement</xforms:label>
                        <xforms:label xml:lang="en-US">Data Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Datenelement</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">data element</xs:documentation>
                    <xs:documentation xml:lang="en-US">data element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Datenelement</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Scenario</xforms:label>
                        <xforms:label xml:lang="en-US">Scenario</xforms:label>
                        <xforms:label xml:lang="de-DE">Szenario</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">scenario</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">scenario</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Szenario</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TR">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Transactie</xforms:label>
                        <xforms:label xml:lang="en-US">Transaction</xforms:label>
                        <xforms:label xml:lang="de-DE">Transaktion</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">transactie</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">transaction</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Transaktion</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="AC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Actoren</xforms:label>
                        <xforms:label xml:lang="en-US">Actors</xforms:label>
                        <xforms:label xml:lang="d-DE">Akteure</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">actoren</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">actors</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Aktoren</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="VS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Waardelijst</xforms:label>
                        <xforms:label xml:lang="en-US">Value Set</xforms:label>
                        <xforms:label xml:lang="de-DE">Value Set</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">value set</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">waardelijst</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Value Set</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="IS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Issue</xforms:label>
                        <xforms:label xml:lang="en-US">Issue</xforms:label>
                        <xforms:label xml:lang="de-DE">Problem/Frage</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">issue</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">issue</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Issue</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="RL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Regel</xforms:label>
                        <xforms:label xml:lang="en-US">Rule</xforms:label>
                        <xforms:label xml:lang="de-DE">Regel</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">regel (intern)</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">rule (internal)</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Regel (intern)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template</xforms:label>
                        <xforms:label xml:lang="en-US">Template</xforms:label>
                        <xforms:label xml:lang="de-DE">Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">template</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">template</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Conceptenlijst</xforms:label>
                        <xforms:label xml:lang="en-US">Concept list</xforms:label>
                        <xforms:label xml:lang="de-DE">Konzeptliste</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">conceptenlijst</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">concept list</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Konzeptliste</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="EL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template-element</xforms:label>
                        <xforms:label xml:lang="en-US">Template Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Template-Element</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">template-element</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">template element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Template-Element</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SX">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Testscenario</xforms:label>
                        <xforms:label xml:lang="en-US">Test Scenario</xforms:label>
                        <xforms:label xml:lang="de-DE">Test-Szenario</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">testscenario</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">test scenario</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Testszenario</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TX">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Test dataelement</xforms:label>
                        <xforms:label xml:lang="en-US">Test Data Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Test Data Element</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">test dataelement</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">test data element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Testdaten-Element</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="EX">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Voorbeeldtransactie</xforms:label>
                        <xforms:label xml:lang="en-US">Example transaction</xforms:label>
                        <xforms:label xml:lang="de-DE">Beispiel-Transaktion</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Example transaction</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Voorbeeldtransactie</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Beispiel-Transaktion</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="QX">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Testeisen</xforms:label>
                        <xforms:label xml:lang="en-US">Test requirements</xforms:label>
                        <xforms:label xml:lang="de-DE">Test-Forderung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Test profile</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Test requirements</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Test-Forderung</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Community</xforms:label>
                        <xforms:label xml:lang="en-US">Community</xforms:label>
                        <xforms:label xml:lang="de-DE">Community</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Community. Expectation is that the DECOR-project assigns ids to communities under this base id, and communities branch under this base</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Community. Verwachting is dat het DECOR-project id's toekent aan communities en dat zij verder vertakken onder deze basis</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Community. Expectation is that the DECOR-project assigns ids to communities under this base id, and communities branch under this base</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Codesysteem</xforms:label>
                        <xforms:label xml:lang="en-US">Code system</xforms:label>
                        <xforms:label xml:lang="de-DE">Codesystem</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Code system</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Codesysteem</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Codesystem</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!--<xs:enumeration value="SD">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">StructureDefinition</xforms:label>
                        <xforms:label xml:lang="en-US">StructureDefinition</xforms:label>
                        <xforms:label xml:lang="de-DE">StructureDefinition</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 FHIR StructureDefinition</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">HL7 FHIR StructureDefinition</xs:documentation>
                    <xs:documentation xml:lang="de-DE">HL7 FHIR StructureDefinition</xs:documentation>
                </xs:annotation>
            </xs:enumeration>-->
            <!--<xs:enumeration value="ID">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Identificatiekoppeling</xforms:label>
                        <xforms:label xml:lang="en-US">Identifier association</xforms:label>
                        <xforms:label xml:lang="de-DE">Identifier association</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Identifier association</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Identificatiekoppeling</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Identifier association</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TA">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Terminologiekoppeling</xforms:label>
                        <xforms:label xml:lang="en-US">Terminology association</xforms:label>
                        <xforms:label xml:lang="de-DE">Terminology association</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Identifier association</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Terminologiekoppeling</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Terminology association</xs:documentation>
                </xs:annotation>
            </xs:enumeration>-->
            <xs:enumeration value="MP">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Concept Map</xforms:label>
                        <xforms:label xml:lang="en-US">Concept Map</xforms:label>
                        <xforms:label xml:lang="de-DE">Concept Map</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Concept Map</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Concept Map</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Concept Map</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="DecorAndOtherObjectFormats">
        <xs:union memberTypes="DecorObjectFormat FhirObjectFormat NonEmptyString"/>
    </xs:simpleType>
    <xs:simpleType name="FhirObjectFormat">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">HL7 FHIR®© Object Formats. Actually matching HL7 FHIR Server package versions. http://hl7.org/fhir/</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="dstu2">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">dstu2</xforms:label>
                        <xforms:label xml:lang="en-US">dstu2</xforms:label>
                        <xforms:label xml:lang="de-DE">dstu2</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">dstu2 otherwise known as 1.0.2</xs:documentation>
                    <xs:documentation xml:lang="en-US">dstu2 otherwise known as 1.0.2</xs:documentation>
                    <xs:documentation xml:lang="de-DE">dstu2 otherwise known as 1.0.2</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="stu3">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">stu3</xforms:label>
                        <xforms:label xml:lang="en-US">stu3</xforms:label>
                        <xforms:label xml:lang="de-DE">stu3</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">stu3 otherwise known as 3.0.0</xs:documentation>
                    <xs:documentation xml:lang="en-US">stu3 otherwise known as 3.0.0</xs:documentation>
                    <xs:documentation xml:lang="de-DE">stu3 otherwise known as 3.0.0</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="DecorObjectFormat">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Decor Object Formats.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="HTML">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HTML</xforms:label>
                        <xforms:label xml:lang="en-US">HTML</xforms:label>
                        <xforms:label xml:lang="de-DE">HTML</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">HTML</xs:documentation>
                    <xs:documentation xml:lang="en-US">HTML</xs:documentation>
                    <xs:documentation xml:lang="de-DE">HTML</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="XML">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">XML</xforms:label>
                        <xforms:label xml:lang="en-US">XML</xforms:label>
                        <xforms:label xml:lang="de-DE">XML</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">XML</xs:documentation>
                    <xs:documentation xml:lang="en-US">XML</xs:documentation>
                    <xs:documentation xml:lang="de-DE">XML</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="JSON">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">JSON</xforms:label>
                        <xforms:label xml:lang="en-US">JSON</xforms:label>
                        <xforms:label xml:lang="de-DE">JSON</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">JSON</xs:documentation>
                    <xs:documentation xml:lang="en-US">JSON</xs:documentation>
                    <xs:documentation xml:lang="de-DE">JSON</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CSV">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">CSV</xforms:label>
                        <xforms:label xml:lang="en-US">CSV</xforms:label>
                        <xforms:label xml:lang="de-DE">CSV</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">CSV</xs:documentation>
                    <xs:documentation xml:lang="en-US">CSV</xs:documentation>
                    <xs:documentation xml:lang="de-DE">CSV</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SQL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">SQL</xforms:label>
                        <xforms:label xml:lang="en-US">SQL</xforms:label>
                        <xforms:label xml:lang="de-DE">SQL</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">SQL</xs:documentation>
                    <xs:documentation xml:lang="en-US">SQL</xs:documentation>
                    <xs:documentation xml:lang="de-DE">SQL</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SVS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">SVS</xforms:label>
                        <xforms:label xml:lang="en-US">SVS</xforms:label>
                        <xforms:label xml:lang="de-DE">SVS</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">SVS</xs:documentation>
                    <xs:documentation xml:lang="en-US">SVS</xs:documentation>
                    <xs:documentation xml:lang="de-DE">SVS</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="ProjectHistory">
        <xs:sequence>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="date" type="TimeStampNoTimezone"/>
        <xs:attribute name="by" type="ShortDescriptiveName"/>
        <xs:attribute name="statusCode" type="ReleaseStatusCodeLifeCycle" use="optional"/>
    </xs:complexType>
    <xs:complexType name="ProjectRelease">
        <xs:sequence>
            <xs:element name="note" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A human readable release note for convenient human rendition; not used by an application.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="date" type="TimeStampNoTimezone"/>
        <xs:attribute name="by" type="ShortDescriptiveName"/>
        <xs:attribute name="versionLabel" type="ShortDescriptiveName">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">A human readable version number or version label for convenient human rendition; not used by an application.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="statusCode" type="ReleaseStatusCodeLifeCycle" use="optional"/>
    </xs:complexType>
    <xs:element name="datasets">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="dataset" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
        <xs:unique name="dataset-idversion-unique">
            <xs:selector xpath="dataset"/>
            <xs:field xpath="@id"/>
            <xs:field xpath="@effectiveDate"/>
        </xs:unique>
    </xs:element>
    <xs:element name="dataset">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate DataSet</sch:title>
                    <sch:rule context="dataset[not(@statusCode=('deprecated','cancelled','rejected'))]">
                        <sch:let name="locationContext" value="concat(' | Location &lt;dataset ', string-join(for $att in (@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:assert role="error" test="(@id and @effectiveDate) or @ref"
                            >ERROR: <sch:name/> SHALL have an @id and @effectiveDate, or a @ref.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@id and @ref)"
                            >ERROR: <sch:name/> SHALL NOT have both @id and @ref.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@canonicalUri and @ref)"
                            >ERROR: <sch:name/> SHALL NOT have both @canonicalUri and @ref.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="property" type="ArbitraryPropertyType" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">Data Set Properties</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="relationship" type="ObjectRelationships" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="concept" type="DataSetConcept" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="id" type="Oid" use="required"/>
            <xs:attribute ref="canonicalUri" use="optional"/>
            <xs:attributeGroup ref="VersionHandling"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="required"/>
            
            <!-- Only relevant after compilation -->
            <xs:attributeGroup ref="DatasetCompilationAttributes"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="ObjectRelationships">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The relationships of the current object to another object. Objects MAY have one or more relationships. Each relationship SHALL point to an object of the same nature. Examples include: datasets can relate to datasets, concepts can relate to concepts, value sets can relate to value sets. Note that relationships are implicit, and unchecked. They are a hint to the reader.</xs:documentation>
        </xs:annotation>
        <xs:attribute name="type" type="RelationshipTypes" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The @type of the relationship, at this point in time something like "SPEC", "GEN", "EQUIV", "VERSION", etc.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ref" type="BasicIdOrOid" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to the objects id or name. Note that while reference by name is supported, it is also discouraged and should only be used when the object is not a DECOR object, but still needs referencing.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to the objects @effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <!-- attribute added in compilation -->
        <xs:attribute ref="refdisplay" use="optional"/>
    </xs:complexType>
    <xs:complexType name="ArbitraryPropertyType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Adds an arbitrary property as name/value pair to its parent. This property SHALL NOT signify/trigger any specific ART-DECOR behavior. This is useful for storing specific information that has no other obvious place and needs to be in a computable place. Examples include external ids, keywords, review status etc. These properties are not meant to be displayed in all contexts, but only in user defined reports/overviews. The 'value' is mixed XHTML compatible content</xs:documentation>
        </xs:annotation>
        <xs:complexContent mixed="true">
            <xs:extension base="VariousMixedContent">
                <xs:attribute name="name" type="NonEmptyString" use="optional">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">Name of the property.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="DataSetConceptValue">
        <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="property" type="DataSetValueProperty" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="conceptList" type="DataSetConceptList" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:appinfo>
                        <sch:pattern>
                            <sch:title>Validate Data Concept List</sch:title>
                            <sch:rule context="dataset//valueDomain/conceptList[not(ancestor::history)]">
                                <sch:let name="locationContext" value="concat(' | Location &lt;concept ', string-join(for $att in ancestor-or-self::concept[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                                
                                <sch:let name="cid" value="@id"/>
                                <sch:let name="cref" value="@ref"/>
                                <!-- In compiled projects, there may legally be multiple instances of the same conceptList -->
                                <sch:assert role="error" test="not(@id) or ancestor::decor[@versionDate] or count(ancestor::datasets//valueDomain/conceptList[@id=$cid][not(ancestor::history)])=1"
                                    >ERROR: The concept list id '<sch:value-of select="$cid"/>' SHALL be unique within the project.<sch:value-of select="$locationContext"/></sch:assert>
                                <sch:assert role="error" test="not(@ref) or ancestor::datasets//valueDomain/conceptList[@id=$cref][not(ancestor::history)]"
                                    >ERROR: The concept list ref '<sch:value-of select="$cref"/>' SHALL have a corresponding conceptList element in the same project.<sch:value-of select="$locationContext"/></sch:assert>
                            </sch:rule>
                        </sch:pattern>
                    </xs:appinfo>
                </xs:annotation>
                <xs:unique name="conceptlist-unique">
                    <xs:selector xpath=".//concept"/>
                    <xs:field xpath="@id"/>
                </xs:unique>
            </xs:element>
            <xs:element ref="example" minOccurs="0" maxOccurs="unbounded"/>
        </xs:choice>
        <xs:attribute name="type" type="DataSetValueType" use="required"/>
    </xs:complexType>
    <xs:complexType name="DataSetValueProperty">
        <xs:attribute name="unit" type="NonEmptyString">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Eenheid</xforms:label>
                    <xforms:label xml:lang="en-US">Unit</xforms:label>
                    <xforms:label xml:lang="de-DE">Einheit</xforms:label>
                </xs:appinfo>
                <xs:documentation>unit for quantities</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="currency" type="NonEmptyString">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Valuta</xforms:label>
                    <xforms:label xml:lang="en-US">Currency</xforms:label>
                    <xforms:label xml:lang="de-DE">Währung</xforms:label>
                </xs:appinfo>
                <xs:documentation>unit for monetary quantities</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="minInclude" type="IntegerOrDecimalRange">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Minimum</xforms:label>
                    <xforms:label xml:lang="en-US">Minimum</xforms:label>
                    <xforms:label xml:lang="de-DE">Minimum</xforms:label>
                </xs:appinfo>
                <xs:documentation>range min include for quantities</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maxInclude" type="IntegerOrDecimalRange">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Maximum</xforms:label>
                    <xforms:label xml:lang="en-US">Maximum</xforms:label>
                    <xforms:label xml:lang="de-DE">Maximum</xforms:label>
                </xs:appinfo>
                <xs:documentation>range max include for quantities</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="fractionDigits" type="FractionDigitsType">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Decimalen</xforms:label>
                    <xforms:label xml:lang="en-US">Digits</xforms:label>
                    <xforms:label xml:lang="de-DE">Ziffern</xforms:label>
                </xs:appinfo>
                <xs:documentation>fraction digits for quantities, e.g. "1" for at least 1 or "1!" for exactly 1</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="timeStampPrecision" type="DataSetTimeStampPrecision">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Tijdstempelprecisie</xforms:label>
                    <xforms:label xml:lang="en-US">Timestamp precision</xforms:label>
                    <xforms:label xml:lang="de-DE">Genauigkeit Zeitangabe</xforms:label>
                </xs:appinfo>
                <xs:documentation>precisions for timing specs</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="default" type="NonEmptyString">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Standard</xforms:label>
                    <xforms:label xml:lang="en-US">Default</xforms:label>
                    <xforms:label xml:lang="de-DE">Standard</xforms:label>
                </xs:appinfo>
                <xs:documentation>default value</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="fixed" type="NonEmptyString">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Vast</xforms:label>
                    <xforms:label xml:lang="en-US">Fixed</xforms:label>
                    <xforms:label xml:lang="de-DE">Fest</xforms:label>
                </xs:appinfo>
                <xs:documentation>fixed value</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="minLength" type="SmallNonNegativeInteger">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Minimumlengte</xforms:label>
                    <xforms:label xml:lang="en-US">Minimum length</xforms:label>
                    <xforms:label xml:lang="de-DE">Minimum länge</xforms:label>
                </xs:appinfo>
                <xs:documentation>min length for strings</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maxLength" type="SmallNonNegativeInteger">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Maximumlengte</xforms:label>
                    <xforms:label xml:lang="en-US">Maximum length</xforms:label>
                    <xforms:label xml:lang="de-DE">Maximum länge</xforms:label>
                </xs:appinfo>
                <xs:documentation>max length for strings</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="DataSetTimeStampPrecision">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Value Domain Time Stamp Precision</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="Y">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">tenminste jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">at least year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">mindestens Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">at least year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="Y!">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">tenminste maand (MM) en jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">at least month (MM) and year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">mindestens Jahr (JJJJ) und Monat (MM)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">at least month (MM) and year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YM!">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">maand (MM) en jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">month (MM) and year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">Monat (MM) und Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">month (MM) and year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YMD">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">tenminste dag (DD), maand (MM) en jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">at least day (DD), month (MM) and year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">mindestens Tag (TT), Monat (MM) und Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">at least day (DD), month (MM) and year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YMD!">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">dag (DD), maand (MM) en jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">day (DD), month (MM) and year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">Tag (TT), Monat (MM) und Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">day (DD), month (MM) and year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YMDHM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">tenminste dag (DD), maand (MM) en jaar (JJJJ), uur (uu) en minuut (mm)</xforms:label>
                        <xforms:label xml:lang="en-US">at least day (DD), month (MM) and year (YYYY), hour (hh) and minute (mm)</xforms:label>
                        <xforms:label xml:lang="de-DE">mindestens Tag (TT), Monat (MM) und Jahr (JJJJ), Stunde (ss) und Minute (mm)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">at least day (DD), month (MM) and year (YYYY), hour (hh) and minute (mm)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="DataSetValueType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Concept Type for the Value Domain</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="count">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Aantal</xforms:label>
                        <xforms:label xml:lang="en-US">Count</xforms:label>
                        <xforms:label xml:lang="de-DE">Count</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Countable (non-monetary) quantities. Used for countable types such as pregnancies, steps (taken by a physiotherapy patient), number of cigarettes
                        smoked in a day.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="code">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Code</xforms:label>
                        <xforms:label xml:lang="en-US">Code</xforms:label>
                        <xforms:label xml:lang="de-DE">Kode</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A system of valid symbols that substitute for specified concepts e.g. alpha, numeric, symbols and/or combinations, usually defined by a formal
                        reference to a terminology or ontology, but may also be defined by the provision of text.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ordinal">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Ordinaal</xforms:label>
                        <xforms:label xml:lang="en-US">Ordinal</xforms:label>
                        <xforms:label xml:lang="de-DE">Ordinal</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Models rankings and scores, e.g. pain, Apgar, reflex, ASA, Tanner values, etc, where there is a) implied ordering, b) no implication that the
                        distance between each value is con- stant, and c) the total number of values is finite. Note that although the term ‘ordinal’ in mathematics means natural numbers only, here
                        any integer is allowed, since negative and zero values are often used by medical professionals for values around a neutral point.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="identifier">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Identificatie</xforms:label>
                        <xforms:label xml:lang="en-US">Identifier</xforms:label>
                        <xforms:label xml:lang="de-DE">Identifier</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Type for representing identifiers of real-world entities. Typical identifiers include drivers licence number, social security number,
                        prescription id, order id, and so on.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="string">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">String</xforms:label>
                        <xforms:label xml:lang="en-US">String</xforms:label>
                        <xforms:label xml:lang="de-DE">String</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Plain text without markup</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="text">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Tekst</xforms:label>
                        <xforms:label xml:lang="en-US">Text</xforms:label>
                        <xforms:label xml:lang="de-DE">Text</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A text item, which may contain any amount of legal characters arranged as e.g. words, sentences etc. Visual formatting and hyperlinks may be
                        included.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="date">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Datum</xforms:label>
                        <xforms:label xml:lang="en-US">Date</xforms:label>
                        <xforms:label xml:lang="de-DE">Datum</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Represents an absolute point in time, as measured on the Gregorian calendar, and specified only to the day. Semantics defined by ISO 8601. Used
                        for recording dates in real world time. The partial form is used for approximate birth dates, dates of death, etc.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="datetime">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Datum+tijd</xforms:label>
                        <xforms:label xml:lang="en-US">Date+time</xforms:label>
                        <xforms:label xml:lang="de-DE">Datum+Zeit</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Represents an absolute point in time, specified to the second. Semantics defined by ISO 8601. Used for recording a precise point in real world
                        time, e.g. the exact date and time of the birth of a baby, and for approximate time stamps, e.g. the origin of an history observation which is only partially
                        known.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="complex">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Samengestelde gegevens</xforms:label>
                        <xforms:label xml:lang="en-US">Collection of data</xforms:label>
                        <xforms:label xml:lang="de-DE">Zusammenstellung von Daten</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">collection of data, e.g. complex specification as part of dosage instructions, a person's name (if not further specified)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="quantity">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Hoeveelheid</xforms:label>
                        <xforms:label xml:lang="en-US">Quantity</xforms:label>
                        <xforms:label xml:lang="de-DE">Quantität</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Quantitified type representing "scientific" quantities, i.e. quantities expressed as a magnitude and units. For time durations duration shall be
                        used; for monetary amounts currency shall be used (not yet available, currently use 'quantity')</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="duration">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Tijdsduur</xforms:label>
                        <xforms:label xml:lang="en-US">Duration</xforms:label>
                        <xforms:label xml:lang="de-DE">Zeitraum</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Is a quantity, represents a period of time with respect to a notional point in time, which is not specified. A sign may be used to indicate the
                        duration is “backwards” in time rather than forwards.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="boolean">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Boolean</xforms:label>
                        <xforms:label xml:lang="en-US">Boolean</xforms:label>
                        <xforms:label xml:lang="de-DE">Boolean</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Items which are truly boolean data, such as true/false or yes/no answers.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="blob">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Binair</xforms:label>
                        <xforms:label xml:lang="en-US">Binary</xforms:label>
                        <xforms:label xml:lang="de-DE">Binary</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Things that are typically stored as binary objects in the computer world and need to be rendered appropriately, e.g. images: like X-rays,
                        computertomographic images and scans.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="decimal">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Decimaal getal</xforms:label>
                        <xforms:label xml:lang="en-US">Decimal number</xforms:label>
                        <xforms:label xml:lang="de-DE">Dezimalzahl</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Decimal number (rarely used, in most cases a decimal number is actually a quantity).</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="DataSetConcept">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Concept, is either a group or an item.</xs:documentation>
            <xs:documentation xml:lang="en-US">A group may contain other groups or items and does not contain a operationalizations or value domain definitions</xs:documentation>
            <xs:documentation xml:lang="en-US">An item typically has operationalizations and value domain definitions and may not contain a concept</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Data Concept</sch:title>
                    <sch:rule context="dataset//concept[@id][not(ancestor::history | parent::conceptList)]">
                        <sch:let name="locationContext" value="concat(' | Location &lt;concept ', string-join(for $att in ancestor-or-self::concept[1]/(@id, @ref, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:let name="did" value="(ancestor-or-self::dataset/@id)[last()]"/>
                        <sch:let name="cid" value="@id"/>
                        <sch:let name="cef" value="@effectiveDate"/>
                        <sch:assert role="error" test="count(ancestor-or-self::dataset//concept[@id=$cid][@effectiveDate=$cef][not(ancestor::history)])=1"
                            >ERROR: A concept within a dataset SHALL be unique with respect to its @id and @effectiveTime (id: <sch:value-of select="$cid"/>, effectiveTime: <sch:value-of select="$cef"/>).<sch:value-of select="$locationContext"/></sch:assert>
                        <!--<sch:report role="warning" test="1=1">XXXXX: (<sch:value-of select="$did"/>)(<sch:value-of select="$cid"/>)</sch:report>-->
                    </sch:rule>
                    
                    <sch:rule context="dataset[@statusCode=('new','draft','pending')]//concept[@statusCode = ('new','draft','pending')][not(ancestor::history | parent::conceptList)]">
                        <sch:let name="locationContext" value="concat(' | Location &lt;concept ', string-join(for $att in ancestor-or-self::concept[1]/(@id, @ref, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:let name="dsid" value="ancestor::dataset[1]/@id"/>
                        <sch:let name="dsed" value="ancestor::dataset[1]/@effectiveDate"/>
                        <sch:let name="dsedmax" value="max(//dataset[@id = $dsid]/xs:dateTime(@effectiveDate))"/>
                        <!-- In compiled projects, concepts will be expanded and include info from the original -->
                        
                        <!--<sch:assert role="error" test="(@id and @effectiveDate) or (@ref and @flexibility)"
                            >ERROR: <sch:name/> SHALL have @id with @effectiveDate, or @ref with @flexibility.<sch:value-of select="$locationContext"/></sch:assert>-->
                        <!--<sch:assert role="error" test="not(@id and (@ref|@flexibility)) or ancestor::decor[@versionDate]"
                            >ERROR: <sch:name/>/@id='<sch:value-of select="@id"/>' SHALL NOT co-occur with @ref or @flexibility.<sch:value-of select="$locationContext"/></sch:assert>-->
                        <!--<sch:assert role="error" test="not(@ref and *) or ancestor::decor[@versionDate]"
                            >ERROR: <sch:name/>/@ref='<sch:value-of select="@ref"/>' SHALL NOT be a reference and have child elements.<sch:value-of select="$locationContext"/></sch:assert>-->
                        <!--<sch:assert role="error" test="not(@ref and (@* except (@ref|@flexibility))) or ancestor::decor[@versionDate]"
                            >ERROR: <sch:name/>/@ref='<sch:value-of select="@ref"/>' SHALL NOT be a reference and have attributes other than @flexibility.<sch:value-of select="$locationContext"/></sch:assert>-->
                        
                        <sch:assert role="error" test="not(inherit and contains)"
                            >ERROR: <sch:name/> SHALL NOT have both inherit and contains.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <!-- if not inherit/@ref then @type and @statusCode SHALL be present -->
                        <sch:assert role="error" test="@type or (inherit | contains)"
                            >ERROR: <sch:name/>/@type SHALL be present if not inherit or contains.<sch:value-of select="$locationContext"/></sch:assert>
                        <!--<sch:assert role="error" test="@statusCode or @ref"
                            >ERROR: <sch:name/>/@statusCode SHALL be present if not contains.<sch:value-of select="$locationContext"/></sch:assert>-->
                        
                        <!-- if inherit/@ref then @type is prohibited -->
                        <sch:assert role="error" test="not(@type and (inherit|contains)) or ancestor::decor[@versionDate]" sqf:fix="removeTypeAttribute"
                            >ERROR: If concept inherits or is a reference then @type SHALL NOT be present.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <!-- if inherit/@ref then @effectiveDate is required -->
                        <sch:assert role="error" test="not(inherit) or (inherit[@ref][@effectiveDate])"
                            >ERROR: If concept has a inherit/@ref then @effectiveDate SHALL be present.<sch:value-of select="$locationContext"/></sch:assert>

                        <!-- if not inherit then name and desc SHALL be present-->
                        <sch:assert role="error" test="inherit | contains | .[name][desc]"
                            >ERROR: <sch:name/> SHALL have at least name and desc, or have an inherit or contains.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(contains) or not(* except (comment|concept|rationale|contains|history)) or ancestor::decor[@versionDate]"
                            >ERROR: <sch:name/> SHALL only have a comment when it has a contains.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(inherit) or not(* except (comment|concept|rationale|inherit|history)) or ancestor::decor[@versionDate]"
                            >ERROR: <sch:name/> SHALL only have a comment and/or child concepts when it has a inherit.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:let name="thisConcept" value="."/>
                        <sch:let name="defaultLanguage" value="ancestor::decor/project/@defaultLanguage"/>
                        <sch:let name="languages" value="ancestor::decor/project/name/@language[not(. = $defaultLanguage)]"/>
                        <sch:let name="emptynames" value="name[string-length(normalize-space())=0]/@language"/>
                        <sch:let name="emptydescriptions" value="desc[string-join(.//text()/normalize-space(),'') = '']/@language"/>
                        <sch:let name="missingnames" value="$languages[not(. = $thisConcept/name/@language)]"/>
                        <sch:let name="missingdescriptions" value="$languages[not(. = $thisConcept/desc/@language)]"/>
                        
                        <!-- if name then it shall be non empty -->
                        <sch:assert role="error" test="empty($emptynames)"
                            >ERROR: A concept name SHALL NOT be empty. Found empty for language(s): <sch:value-of select="string-join($emptynames,', ')"/>.<sch:value-of select="$locationContext"/></sch:assert>
                        <!-- if desc then it shall be non empty -->
                        <sch:report role="warning" test="desc[@language = $defaultLanguage][not(string-join(.//text()/normalize-space(),'') = '')] and $emptydescriptions"
                            >WARNING: A concept desc (definition) SHOULD NOT be empty. Found empty for language(s): <sch:value-of select="string-join($emptydescriptions,', ')"/><sch:value-of select="$locationContext"/></sch:report>
                        
                        <sch:assert role="error" test="not(name) or name[@language = $defaultLanguage]"
                            >ERROR: Concept SHALL have a name in the default project language (<sch:value-of select="$defaultLanguage"/>).<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(desc) or desc[@language = $defaultLanguage]"
                            >ERROR: Concept SHALL have a desc in the default project language (<sch:value-of select="$defaultLanguage"/>).<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="info" test="not(name) or empty($missingnames)"
                            >INFO: Concept is missing a name in one or more of the defined project languages (<sch:value-of select="$missingnames"/>).<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="info" test="not(desc) or empty($missingdescriptions)"
                            >INFO: Concept is missing a desc in one or more of the defined project languages (<sch:value-of select="$missingdescriptions"/>).<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <!--
                        <sch:assert test="string-length(name)>1">ERROR: Concept/name SHALL be a short string.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert test="string-length(desc)>1">ERROR: Concept/name SHALL be a short string.<sch:value-of select="$locationContext"/></sch:assert>
                        -->
                        <sch:let name="inhcid" value="inherit/@ref"/>
                        <sch:let name="inhced" value="inherit/@effectiveDate"/>
                        <sch:let name="inhcedmax" value="max(//dataset//concept[@id = $inhcid][not(ancestor::history)]/xs:dateTime(@effectiveDate))"/>
                        <sch:let name="inhc" value="//dataset//concept[@id=$inhcid][@effectiveDate=$inhced][not(ancestor::history|parent::conceptList)]"/>
                        <sch:let name="inhctype" value="$inhc/@type"/>
                        <sch:let name="ctype" value="if (.[@type]) then (@type) else if (count($inhctype)=1 and $inhc/concept and string-length($inhctype)&gt;0) then ($inhctype) else ('')"/>
                        <sch:assert role="error" test="($ctype='group' and count(concept)&gt;0 and count(valueDomain)=0) or not($ctype='group') or ($ctype='group' and contains)"
                            >ERROR: A concept of (inherited) type group SHOULD have concept child definition(s).<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="($ctype='item' and count(concept)=0) or not($ctype='item')"
                            >ERROR: A concept of (inherited) type item SHOULD NOT have concept child definition(s).<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(string-join($inhctype,'')='item' and count(valueDomain)&gt;0) or ancestor::decor[@versionDate]"
                            >ERROR: A concept of inherited type item SHOULD NOT have a value domain definition.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:report role="warning" test="@type='item' and count(valueDomain[@type])=0 and count(inherit)=0"
                            >WARNING: A concept of type item SHOULD have a value domain with a type definition.<sch:value-of select="$locationContext"/></sch:report>
                        <sch:assert role="error" test="count($inhctype) &lt;= 1"
                            >ERROR: Concept id <sch:value-of select="@id"/> and effective date <sch:value-of select="@effectiveDate"/> has ambiguous inheritance as the concept it inherits from is a duplicate.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:let name="cid" value="@id"/>
                        <sch:let name="ced" value="@effectiveDate"/>
                        <sch:let name="cedmax" value="max(//dataset//concept[@id = $cid][not(ancestor::history)]/xs:dateTime(@effectiveDate))"/>
                        <sch:let name="cnm" value="if (inherit[@ref]) then ($inhc/name/text())[1] else (name[string-length()>0][1]/text())"/>
                        <sch:let name="isInTransaction" value="//representingTemplate[@sourceDataset = $dsid][@sourceDatasetFlexibility = $dsed or ($dsed = $dsedmax and not(@sourceDatasetFlexibility castable as xs:dateTime))][@ref]/concept[@ref=$cid][@flexibility = $ced or ($ced = $cedmax and not(@flexibility castable as xs:dateTime))][ancestor::transaction/@statusCode=('draft','final')][ancestor::scenario/@statusCode=('draft','final')]"/>
                        <sch:let name="isInTemplate" value="//rules/templateAssociation/concept[@ref=$cid][@effectiveDate = $ced or ($ced = $cedmax and not(@effectiveDate castable as xs:dateTime))]"/>
                        <sch:let name="rulesDefined" value="//rules[template]"/>
                        <sch:assert role="info" test="not($isInTransaction) or $isInTemplate or not($rulesDefined)"
                            >INFO: Concept <sch:value-of select="$ctype"/> with conceptId '<sch:value-of select="$cid"/>' ('<sch:value-of select="$cnm"/>') is used in at least one transaction, but does not have a templateAssociation.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:let name="inhconcept" value="(//datasets//concept[@id=$inhcid][@effectiveDate = $inhced or ($inhced = $inhcedmax and not(@effectiveDate castable as xs:dateTime))][not(ancestor-or-self::history|parent::conceptList)])[1]"/>
                        <sch:assert role="info" test="not(inherit) or not($inhconcept/inherit)" sqf:fix="replaceInheritWithIdOfOriginalConcept"
                            >INFO: This concept inherits from a concept that inherits. For performance reasons it SHOULD inherit from the original concept ref="<sch:value-of select="$inhconcept/inherit/@ref"/>" effectiveDate="<sch:value-of select="$inhconcept/inherit/@effectiveDate"/>".<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="warning" test="not($inhconcept[@statusCode=('cancelled','deprecated','rejected')])"
                            >WARNING: A concept SHOULD NOT inherit from a concept with an inactive status (<sch:value-of select="$inhconcept/@statusCode"/>).<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <!-- Only relevant after compilation -->
            <xs:group ref="DatasetConceptCompilationImplementation"/>
            <xs:element name="inherit" type="InheritDefinition" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept inherits properties from another concept. Inherit is pulled into the current structure and will fail on circular references</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="contains" type="ContainsDefinition" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept references properties from another concept. Contains is not pulled into the current structure and is suited for circular references</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Name (short). One name per language.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="synonym" type="BusinessNameWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Synonym for a Data Set Concept Name (short). Can have multiple synonyms per language.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Description (long). One to many descriptions per language</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="source" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Source, human readable hint where this data element originally comes from</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="rationale" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set rationale, human readable justification or explanation why this concept is present</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="comment" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept comments</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="property" type="ArbitraryPropertyType" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept properties</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="relationship" type="ObjectRelationships" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept relationship to another data set concept.</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- following elements for type item only -->
            <xs:element name="operationalization" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Operationalization, e.g. how to measure, obtain, specify the value of an observation</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="valueDomain" type="DataSetConceptValue" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Value Domain, properties of the value in an instance</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- Only relevant after compilation -->
            <xs:group ref="DatasetConceptCompilationValueSet"/>
            <!-- Only relevant after compilation -->
            <xs:group ref="DatasetConceptCompilationTerminologyAssociation"/>
            
            <!-- Only relevant after compilation -->
            <xs:group ref="DatasetConceptCompilationIdentifierAssociation"/>
            
            <!-- following elements for type group only -->
            <xs:element name="concept" type="DataSetConcept" minOccurs="0" maxOccurs="unbounded"/>

            <!-- history -->
            <xs:element name="history" type="DataSetConceptHistory" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept History</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <!--
            attributes checked by schematrons, see above
        -->
        <xs:attribute name="id" type="Oid" use="required"/>
        <xs:attribute ref="canonicalUri" use="optional"/>
        <xs:attributeGroup ref="VersionHandling"/>
        <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="required"/>
        <xs:attribute name="type" type="DataSetConceptType" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Prohibited when concept is a reference through inherit or contains. Required in all other cases.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        
        <!-- Only relevant after compilation -->
        <xs:attributeGroup ref="DatasetConceptCompilationAttributes"/>
    </xs:complexType>
    <xs:complexType name="DataSetConceptHistory">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Concept History of either a group or an item.</xs:documentation>
            <xs:documentation xml:lang="en-US">A Concept History may not contain nested history items</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="concept" type="DataSetConcept" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="validTimeHigh" use="required" type="TimeStampNoTimezone">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The time that the given information ceased to be correct.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="DataSetConceptType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Concept Type</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="group">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Groep</xforms:label>
                        <xforms:label xml:lang="en-US">Group</xforms:label>
                        <xforms:label xml:lang="de-DE">Gruppe</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">group of data set items</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">groep van data set items</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Gruppe von Dataset-Items</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="item">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Item</xforms:label>
                        <xforms:label xml:lang="en-US">Item</xforms:label>
                        <xforms:label xml:lang="de-DE">Item</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">data set item</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">datasetitem</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Dataset-Item</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ProcessCode">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Type of processing</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="strict">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Strikt</xforms:label>
                        <xforms:label xml:lang="en-US">Strict</xforms:label>
                        <xforms:label xml:lang="de-DE">Strikt</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="lax">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Los</xforms:label>
                        <xforms:label xml:lang="en-US">Lax</xforms:label>
                        <xforms:label xml:lang="de-DE">Locker</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="DataSetConceptList">
        <xs:annotation>
            <xs:appinfo>
                <!--sch:pattern name="Validate ConceptList TerminologyAssociation">
                    <sch:rule context="dataset//conceptList[@id]">
                        <sch:let name="pcId" value="(ancestor::concept)[1]/@id"/>
                        <sch:let name="pcType" value="(ancestor::valueDomain)[1]/@type"/>
                        <sch:let name="cId" value="@id"/>
                        <sch:assert role="warning" test="not($pcType='code') or //terminology/terminologyAssociation[@conceptId=$cId]"
                            >WARNING: The concept list <sch:value-of select="$cId"/> inside concept item <sch:value-of select="$pcId"/> SHOULD have a terminologyAssociation.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern-->
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="concept" type="DataSetConceptListConcept" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Defines the globally unique identifier for this conceptList and may be used to reference it. Concept lists SHOULD carry either @id or @ref</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ref" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a conceptList/@id. Concept lists SHOULD carry either @id or @ref</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="DataSetConceptListConcept">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Concept TerminologyAssociation</sch:title>
                    <sch:rule context="dataset//conceptList[not(ancestor::history)][not(ancestor::*/@statusCode=('deprecated','cancelled','rejected'))]/concept[@id]">
                        <sch:let name="locationContext" value="concat(' | Location &lt;concept ', string-join(for $att in ancestor-or-self::concept[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        <sch:let name="pcId" value="ancestor::concept[1]/@id"/>
                        <sch:let name="clId" value="parent::conceptList/@id"/>
                        <sch:let name="clHasTermAssoc" value="//terminologyAssociation[@conceptId=$clId]"/>
                        <sch:let name="cId" value="@id"/>
                        <sch:let name="cHasTermAssoc" value="//terminologyAssociation[@conceptId=$cId]"/>
                        <sch:assert role="warning" test="not(exists($clHasTermAssoc)) or exists($cHasTermAssoc)"
                            >WARNING: The concept <sch:value-of select="$cId"/> SHOULD have a terminologyAssociation as the conceptList has a valueSet binding.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
            <xs:element name="synonym" type="BusinessNameWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Synonym for a Data Set Concept List Item Name (short). Can have multiple synonyms per language.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="Oid" use="optional"/>
        <xs:attribute name="exception" type="xs:boolean">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">indicates whether this is an exceptional concept (for example: unknown)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <!-- AH: 2016-03-02 Brings dataset conceptList/concepts on par with valueSet/conceptList/concepts
                It may take a very long time between creating the dataset and adding the bindings. It also 
                opens discussion between terminologists and the datset designers that otherwise would have been hidden
                when the level/type in the dataset cannot be matched in the terminology.
        -->
        <xs:attribute name="level" type="xs:integer" use="optional"/>
        <xs:attribute name="type" type="VocabType" use="optional"/>
    </xs:complexType>
    <xs:element name="scenarios">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="actors" minOccurs="1" maxOccurs="1"/>
                <xs:element ref="scenario" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="instances" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
        <xs:unique name="scenario-idversion-unique">
            <xs:selector xpath="scenario"/>
            <xs:field xpath="@id"/>
            <xs:field xpath="@effectiveDate"/>
        </xs:unique>
        <xs:unique name="transaction-idversion-unique">
            <xs:selector xpath=".//transaction"/>
            <xs:field xpath="@id"/>
            <xs:field xpath="@effectiveDate"/>
        </xs:unique>
    </xs:element>
    <xs:element name="instances">
        <xs:complexType>
            <xs:sequence>
                <xs:any processContents="skip" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="displayName" type="ShortDescriptiveName" use="optional"/>
            <xs:attribute name="effectiveDate" type="TimeStampNoTimezone"  use="required"/>
            <xs:attribute name="ref" type="Oid" use="required"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="required"/>
            <xs:attribute name="process" type="ProcessCode"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="scenario">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Scenario that describes a business process</xs:documentation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:rule context="scenario[not(ancestor-or-self::*/@statusCode=('deprecated','cancelled','rejected'))] | scenario//transaction[not(ancestor-or-self::*/@statusCode=('deprecated','cancelled','rejected'))]">
                            <sch:let name="locationContext" value="concat(' | Location &lt;scenario ', string-join(for $att in (@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                            
                            <sch:let name="thisConcept" value="."/>
                            <sch:let name="defaultLanguage" value="ancestor::decor/project/@defaultLanguage"/>
                            <sch:let name="languages" value="ancestor::decor/project/name/@language[not(. = $defaultLanguage)]"/>
                            <sch:let name="emptynames" value="name[string-length(normalize-space())=0]/@language"/>
                            <sch:let name="emptydescriptions" value="desc[string-join(.//text()/normalize-space(),'') = '']/@language"/>
                            <sch:let name="missingnames" value="$languages[not(. = $thisConcept/name/@language)]"/>
                            <sch:let name="missingdescriptions" value="$languages[not(. = $thisConcept/desc/@language)]"/>
                            
                            <!-- if name then it shall be non empty -->
                            <sch:assert role="error" test="empty($emptynames)"
                                >ERROR: <sch:name/> name SHALL NOT be empty. Found empty for language(s): <sch:value-of select="string-join($emptynames,', ')"/>.<sch:value-of select="$locationContext"/></sch:assert>
                            <!-- if desc then it shall be non empty -->
                            <sch:assert role="info" test="empty($emptydescriptions)"
                                >INFO: <sch:name/> desc (definition) SHOULD NOT be empty. Found empty for language(s): <sch:value-of select="string-join($emptydescriptions,', ')"/><sch:value-of select="$locationContext"/></sch:assert>
                            
                            <sch:assert role="error" test="not(name) or name[@language = $defaultLanguage]"
                                >ERROR: <sch:name/> SHALL have a name in the default project language (<sch:value-of select="$defaultLanguage"/>).<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(desc) or desc[@language = $defaultLanguage]"
                                >ERROR: <sch:name/> SHALL have a desc in the default project language (<sch:value-of select="$defaultLanguage"/>).<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="info" test="not(name) or empty($missingnames)"
                                >INFO: <sch:name/> is missing a name in one or more of the defined project languages (<sch:value-of select="$missingnames"/>).<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="info" test="not(desc) or empty($missingdescriptions)"
                                >INFO: <sch:name/> is missing a desc in one or more of the defined project languages (<sch:value-of select="$missingdescriptions"/>).<sch:value-of select="$locationContext"/></sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:sequence>
                <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="trigger" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="condition" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="transaction" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
            <!-- Deprecated. Having a name element and a @displayName attribute makes no sense. Was not in use at deprecation time -->
            <!--xs:attribute name="displayName" type="ShortDescriptiveName" use="optional"/-->
            <xs:attribute name="id" use="required" type="Oid"/>
            <xs:attributeGroup ref="VersionHandling"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="transaction">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Transaction group or singular transaction</xs:documentation>
                <xs:documentation xml:lang="nl-NL">Transactiegroep of enkelvoudige transactie</xs:documentation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:rule context="scenario//transaction[not(ancestor-or-self::*/@statusCode=('deprecated','cancelled','rejected'))]">
                            <sch:let name="locationContext" value="concat(' | Location &lt;transaction ', string-join(for $att in ancestor-or-self::transaction[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility, @statusCode) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                            
                            <sch:assert role="error" test="(@id and @effectiveDate) or @ref"
                                >ERROR: <sch:name/> SHALL have an @id and @effectiveDate, or a @ref.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@id and @ref)"
                                >ERROR: <sch:name/> SHALL NOT have both @id and @ref.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@canonicalUri and @ref)"
                                >ERROR: <sch:name/> SHALL NOT have both @canonicalUri and @ref.<sch:value-of select="$locationContext"/></sch:assert>
                            
                            <sch:assert role="error" test="not(@model) or @type"
                                >ERROR: A transaction with an underlying model SHALL have a @type.<sch:value-of select="$locationContext"/></sch:assert>
                            <!--<sch:assert test="not(@type='group' and (@effectiveDate or @statusCode))">ERROR: Transaction group SHALL NOT have version attributes @effectiveDate and @statusCode.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert test="@type='group' or (@effectiveDate and @statusCode)">ERROR: Transaction item SHALL have version attributes @effectiveDate and @statusCode.<sch:value-of select="$locationContext"/></sch:assert>-->
                            <sch:assert role="error" test="@effectiveDate and @statusCode"
                                >ERROR: Transaction SHALL have version attributes @effectiveDate and @statusCode.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@label and (transaction or @type='group'))"
                                >ERROR: Transaction groups SHALL NOT have a schematron label.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(representingTemplate[@ref]) or @label"
                                >ERROR: Transaction with a representing template SHALL have a schematron label.<sch:value-of select="$locationContext"/></sch:assert>
                            
                            <!-- Validate transaction label -->
                            <sch:let name="scenarioStatus" value="ancestor::scenario/@statusCode"/>
                            <sch:let name="allLabels" value="//scenario//transaction/@label"/>
                            <sch:let name="currentLabel" value="@label"/>
                            <sch:report role="error" test="$currentLabel and $scenarioStatus=('new','draft','pending') and count($allLabels[.=$currentLabel])>1"
                                >ERROR: Transaction @label '<sch:value-of select="$currentLabel"/>' within a '<sch:value-of select="$scenarioStatus"/>' scenario MUST be unique in this DECOR file.<sch:value-of select="$locationContext"/></sch:report>
                            <sch:report role="warning" test="$currentLabel and not($scenarioStatus=('new','draft','pending')) and count($allLabels[.=$currentLabel])>1"
                                >WARNING: Transaction @label '<sch:value-of select="$currentLabel"/>' within a '<sch:value-of select="$scenarioStatus"/>' scenario SHOULD be unique in this DECOR file.<sch:value-of select="$locationContext"/></sch:report>
                            
                            <!-- Validate Transaction Type group -->
                            <sch:assert role="error" test="not(@type='group') or parent::*[1][local-name()='scenario']"
                                >ERROR: Transaction groups SHALL be immediate children of scenario.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@type='group') or not(.//transaction[@type='group'])"
                                >ERROR: Transaction groups SHALL NOT contain transaction groups.<sch:value-of select="$locationContext"/></sch:assert>
                            
                            <!-- Validate Transaction Type initial -->
                            <sch:assert role="error" test="not(@type='initial') or parent::*[1][local-name()='transaction'][@type='group']"
                                >ERROR: Transactions of type 'initial' SHALL be immediate children of a transaction group.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@type='initial') or (count(actors/actor[@role='sender']) &gt;=1 and count(actors/actor[@role='receiver']) &gt;=1)"
                                >ERROR: Transactions of type 'initial' SHALL have at least 1 'sender' actor and at least 1 'receiver' actor.<sch:value-of select="$locationContext"/></sch:assert>
                            
                            <!-- Validate Transaction Type back -->
                            <sch:assert role="error" test="not(@type='back') or parent::*[1][local-name()='transaction'][@type='group']"
                                >ERROR: Transactions of type 'back' SHALL be immediate children of a transaction group.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@type='back') or preceding-sibling::transaction[@type='initial']"
                                > ERROR: Transactions of type 'back' SHALL be preceded by a transaction of type 'initial'.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@type='back') or (count(actors/actor[@role='sender']) &gt;=1 and count(actors/actor[@role='receiver']) &gt;=1)"
                                >ERROR: Transactions of type 'back' SHALL have at least 1 'sender' actor and at least 1 'receiver' actor.<sch:value-of select="$locationContext"/></sch:assert>
                            
                            <!-- Validate Transaction Type stationary -->
                            <sch:assert role="error" test="not(@type='stationary') or parent::*[1][local-name()='transaction'][@type='group']"
                                >ERROR: Transactions of type 'stationary' SHALL be immediate children of a transaction group.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@type='stationary') or not(preceding-sibling::transaction[position()=1][@type='back'] | following-sibling::transaction[position()=1][@type='back'])"
                                >ERROR: Transactions of type 'stationary' SHALL NOT be preceded or followed by a transaction of type 'back'.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@type='stationary') or (count(actors/actor[@role='sender'])=1 and count(actors/actor)=1)"
                                >ERROR: Transactions of type 'stationary' SHALL have exactly 1 actor of type 'sender'.<sch:value-of select="$locationContext"/></sch:assert>
                        </sch:rule>
                        
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:sequence minOccurs="0">
                <xs:sequence>
                    <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                    <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="trigger" type="TransactionTrigger" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="condition" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="dependencies" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:choice>
                    <xs:sequence>
                        <xs:element name="actors" type="ActorsReference" minOccurs="1" maxOccurs="1"/>
                        <xs:element ref="representingTemplate" minOccurs="0"/>
                    </xs:sequence>
                    <xs:element ref="transaction" minOccurs="0" maxOccurs="unbounded"/>
                </xs:choice>
            </xs:sequence>
            <!-- Deprecated. Having a name element and a @displayName attribute makes no sense. Was not in use at deprecation time -->
            <!--xs:attribute name="displayName" type="ShortDescriptiveName" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Display name for this transaction</xs:documentation>
                </xs:annotation>
            </xs:attribute-->
            <xs:attribute name="id" use="required" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Globally and persistently unique identifier</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute ref="canonicalUri" use="optional"/>
            <xs:attribute name="model" type="xs:NCName">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Root element name for the XML structure without namespace prefix that represents this transaction. For HL7 V3 messaging this could be REPC_IN004410UV, for HL7 V2 messaging this could be ADT_A01</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="label" type="xs:NCName">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Constitutes the value for the schematron file with the project prefix (//project/@prefix)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="type" type="TransactionType" use="required"/>
            <xs:attributeGroup ref="VersionHandling"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="optional"/>
            
            <!-- Only relevant after compilation -->
            <xs:attributeGroup ref="DatasetCompilationAttributes"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="TransactionTrigger">
        <xs:complexContent mixed="true">
            <xs:extension base="FreeFormMarkupWithLanguage">
                <xs:attribute name="id" use="optional" type="xs:NCName"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:simpleType name="TransactionType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Allows specification of the type of a transaction.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationString">
            <xs:enumeration value="group">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Groep</xforms:label>
                        <xforms:label xml:lang="en-US">Group</xforms:label>
                        <xforms:label xml:lang="de-DE">Gruppe</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A transaction of type 'group' groups transactions of other types</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="initial">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Initieel</xforms:label>
                        <xforms:label xml:lang="en-US">Initial</xforms:label>
                        <xforms:label xml:lang="de-DE">Initial</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A transaction of type 'initial' says that this is the transaction that is initially sent, and usually invokes a response. This transaction type
                        requires at least a 'sender' and a 'receiver' actor.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="back">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Terug</xforms:label>
                        <xforms:label xml:lang="en-US">Back</xforms:label>
                        <xforms:label xml:lang="de-DE">Zurück</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A transaction of type 'back' says that this transaction is sent in response to another transaction that preceded this one. Transactions of type
                        'back' may invoke a new transaction, but this is again of type initial. This transaction type requires at least a 'sender' and a 'receiver' actor.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="stationary">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Registratie</xforms:label>
                        <xforms:label xml:lang="en-US">Stationary</xforms:label>
                        <xforms:label xml:lang="de-DE">Stationär</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A transaction of type 'stationary' says that this transaction does not involve communication, but rather the local registration/administration of
                        data. Transactions of type 'stationary' do not invoke new transaction. This transaction type requires exactly one 'sender' actor.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="actors">
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" maxOccurs="unbounded" name="actor" type="ActorDefinition"/>
            </xs:sequence>
        </xs:complexType>
        <xs:unique name="scenarios-actor-unique">
            <xs:selector xpath="actor"/>
            <xs:field xpath="@id"/>
        </xs:unique>
    </xs:element>
    <xs:complexType name="ActorsReference">
        <xs:sequence>
            <xs:element minOccurs="1" maxOccurs="unbounded" name="actor" type="ActorReference"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="ActorDefinition">
        <xs:sequence>
            <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="Oid" use="required"/>
        <xs:attribute name="type" type="ScenarioActorType" use="required"/>
        <!-- 2DO should be person|device etc -->
    </xs:complexType>
    <xs:simpleType name="ScenarioActorType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Actor type for use in scenarios and transactions</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="person">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Persoon</xforms:label>
                        <xforms:label xml:lang="en-US">Person</xforms:label>
                        <xforms:label xml:lang="de-DE">Person</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Person</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="organization">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Organisatie</xforms:label>
                        <xforms:label xml:lang="en-US">Organization</xforms:label>
                        <xforms:label xml:lang="de-DE">Organisation</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Organization</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="device">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Systeem</xforms:label>
                        <xforms:label xml:lang="en-US">Device</xforms:label>
                        <xforms:label xml:lang="de-DE">Gerät</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Device</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="ActorReference">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Actor reference references an actor that is defined in the main list of actors for all scenarios</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Actor Reference</sch:title>
                    <sch:rule context="scenario//transaction[not(ancestor-or-self::*/@statusCode=('deprecated','cancelled','rejected'))]/actors/actor">
                        <sch:let name="locationContext" value="concat(' | Location &lt;transaction ', string-join(for $att in ancestor-or-self::transaction[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        <sch:let name="actorId" value="@id"/>
                        <sch:assert role="error" test="ancestor::scenarios/actors/actor[@id = $actorId]"
                            >ERROR: An actor reference SHALL reference an actor in the main list of actors for all scenarios. <sch:value-of select="$actorId"/> does not exist.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:attribute name="id" use="required" type="Oid"/>
        <xs:attribute name="role" type="ActorType"/>
    </xs:complexType>
    <xs:simpleType name="ActorType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Type of role the actor plays in a transaction</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="sender">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Zender</xforms:label>
                        <xforms:label xml:lang="en-US">Sender</xforms:label>
                        <xforms:label xml:lang="de-DE">Sender</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This actor is the sender of the transaction</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="receiver">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Ontvanger</xforms:label>
                        <xforms:label xml:lang="en-US">Receiver</xforms:label>
                        <xforms:label xml:lang="de-DE">Empfänger</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This actor is the receiver of the transaction</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="stationary">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Registratie</xforms:label>
                        <xforms:label xml:lang="en-US">Stationary</xforms:label>
                        <xforms:label xml:lang="de-DE">Stationär</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This actor is the person or device responsible for persisting the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="representingTemplate">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate sourceDataset with concepts</sch:title>
                        <sch:rule context="scenario//transaction[not(ancestor-or-self::*/@statusCode=('deprecated','cancelled','rejected','final'))]/representingTemplate/concept">
                            <sch:let name="locationContext" value="concat(' | Location &lt;transaction ', string-join(for $att in ancestor-or-self::transaction[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                            <sch:let name="cid" value="@ref"/>
                            <sch:assert role="error" test="not(@isMandatory='true' and @minimumMultiplicity='0')"
                                >ERROR: Transaction concept ref="<sch:value-of select="$cid"/>", if isMandatory=true, minimumMultiplicity SHALL be greater than 0.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(condition[@isMandatory='true' and @minimumMultiplicity='0'])"
                                >ERROR: Transaction concept ref="<sch:value-of select="$cid"/>", if isMandatory=true, minimumMultiplicity SHALL be greater than 0.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@minimumMultiplicity castable as xs:integer and @maximumMultiplicity castable as xs:integer) or xs:integer(@minimumMultiplicity) &lt;= xs:integer(@maximumMultiplicity)"
                                >ERROR: Transaction concept ref="<sch:value-of select="$cid"/>", minimumMultiplicity <sch:value-of select="@minimumMultiplicity"/> SHALL be smaller than or equal to maximumMultiplicity <sch:value-of select="@maximumMultiplicity"/>.<sch:value-of select="$locationContext"/></sch:assert>
                            
                            <sch:assert role="error" test="(@minimumMultiplicity or @maximumMultiplicity or @conformance='NP') or (@conformance='C' and count(condition)&gt;0)"
                                >ERROR: Transaction concept ref="<sch:value-of select="$cid"/>", SHALL contain cardinality or conditions.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:report role="warning" test="@conformance='C' and count(condition)=0"
                                >WARNING: Conditional transaction concept ref="<sch:value-of select="$cid"/>", SHOULD contain conditions.<sch:value-of select="$locationContext"/></sch:report>
                            <sch:report role="warning" test="@conformance='C' and (@minimumMultiplicity or @maximumMultiplicity)"
                                >WARNING: Conditional transaction concept ref="<sch:value-of select="$cid"/>", SHOULD have the @minimumMultiplicity and/or @maximumMultiplicity on its conditions.<sch:value-of select="$locationContext"/></sch:report>
                            <sch:let name="repTemp" value="parent::*"/>
                            <sch:let name="dsid" value="parent::*/@sourceDataset"/>
                            <sch:let name="dsed" value="parent::*/@sourceDatasetFlexibility[not(.='dynamic')]"/>
                            <sch:let name="reffedDataset" value="//datasets/dataset[@id=$dsid][@effectiveDate=$dsed or not($dsed)]"/>
                            <sch:let name="reffedConcept" value="$reffedDataset//concept[@id=$cid][not(parent::conceptList)][not(ancestor::history)]"/>
                            <sch:assert role="error" test="not($reffedDataset) or $reffedDataset//concept[@id=$cid][not(ancestor::history)][not(parent::conceptList)] or $reffedDataset//concept[@ref]"
                                >ERROR: Transaction concept ref="<sch:value-of select="$cid"/>", SHALL exist in dataset/@id='<sch:value-of select="$dsid"/>' @effectiveDate='<sch:value-of select="$reffedDataset/@effectiveDate"/>' (<sch:value-of select="$reffedDataset/name[string-length()>0][1]"/>).<sch:value-of select="$locationContext"/></sch:assert>
                            
                            <!-- Scenario currently has statusCode and transaction currently doesn't. Check should still work if transaction is to have a statusCode -->
                            <sch:let name="dsStatus" value="$reffedDataset/@statusCode"/>
                            <sch:let name="dsStatusActive" value="$dsStatus=('new','draft','final','pending')"/>
                            <sch:let name="cptStatus" value="$reffedConcept/@statusCode"/>
                            <sch:let name="cptStatusActive" value="$cptStatus=('new','draft','final','pending')"/>
                            <sch:assert role="warning" test="not($dsStatusActive) or $cptStatusActive"
                                >WARNING: Transaction concept ref="<sch:value-of select="$cid"/>", SHOULD, while you may still edit it, point to a new, draft, pending or final concept, but found '<sch:value-of select="$cptStatus"/>'.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:let name="missingParentLevel" value="$reffedConcept/parent::concept[not(@id = $repTemp/concept/@ref)]"/>
                            <sch:assert role="error" test="not($reffedConcept) or not($missingParentLevel)" sqf:fix="addConceptParentsInTransaction"
                                >ERROR: Transaction concept ref="<sch:value-of select="$cid"/>" is missing one or more parent groups active in the transaction. This may have happened because of moved concepts in the dataset. You should check this transaction and activate the missing parent concept groups.<sch:value-of select="$locationContext"/></sch:assert>
                        </sch:rule>
                        <sch:rule context="scenario//transaction[not(ancestor-or-self::*/@statusCode=('deprecated','cancelled','rejected'))]/representingTemplate/concept/condition">
                            <sch:let name="locationContext" value="concat(' | Location &lt;transaction ', string-join(for $att in ancestor-or-self::transaction[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                            <sch:let name="cid" value="ancestor::concept[1]/@ref"/>
                            <sch:assert role="error" test="not(@minimumMultiplicity castable as xs:integer and @maximumMultiplicity castable as xs:integer) or xs:integer(@minimumMultiplicity) &lt;= xs:integer(@maximumMultiplicity)"
                                >ERROR: Transaction concept ref="<sch:value-of select="$cid"/>", minimumMultiplicity <sch:value-of select="@minimumMultiplicity"/> SHALL be smaller than or equal to maximumMultiplicity <sch:value-of select="@maximumMultiplicity"/>.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:let name="textContents" value="string-length(normalize-space(string-join(text(),'')))"/>
                            <sch:assert role="error" test="(count(*)=0 and $textContents=0) or (count(*)>0 and $textContents=0) or (count(*)=0 and $textContents>0)"
                                >ERROR: Transaction concept ref="<sch:value-of select="$cid"/>", SHALL have conditions with text only or element only (no mixed content).<sch:value-of select="$locationContext"/></sch:assert>
                        </sch:rule>
                        <sch:rule context="scenario//transaction[not(ancestor-or-self::*/@statusCode=('deprecated','cancelled','rejected'))]/representingTemplate[@ref]">
                            <sch:let name="locationContext" value="concat(' | Location &lt;transaction ', string-join(for $att in ancestor-or-self::transaction[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                            <sch:let name="tmid" value="@ref"/>
                            <sch:let name="flextext" value="if (@flexibility) then (@flexibility) else ('dynamic')"/>
                            <sch:let name="matches" value="//rules/template[(@id|@name)=$tmid]/xs:dateTime(@effectiveDate)"/>
                            <sch:let name="tmed" value="if (matches(@flexibility,'^\d{4}')) then (@flexibility) else (max($matches))"/>
                            <sch:let name="reffedTemplate" value="//rules/template[(@id|@name)=$tmid][@effectiveDate=$tmed] | //rules/template[@ref=$tmid]"/>
                            <sch:assert role="error" test="count(concept) = 0 or string-length(@sourceDataset)&gt;0"
                                >ERROR: A representing template with concept references SHALL have a sourceDataset.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@ref) or $reffedTemplate"
                                >ERROR: <sch:name/>/@ref='<sch:value-of select="$tmid"/>' MUST point to an existing template with flexibility '<sch:value-of select="$flextext"/>' -<sch:value-of select="$matches"/>-.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@ref) or not($reffedTemplate[@id]) or $reffedTemplate[context]"
                                >ERROR: <sch:name/>/@ref='<sch:value-of select="$tmid"/>' MUST point to an existing template with a context element.<sch:value-of select="$locationContext"/></sch:assert>
                        </sch:rule>
                        <sch:rule context="scenario//transaction[not(ancestor-or-self::*/@statusCode=('deprecated','cancelled','rejected'))]/representingTemplate[@sourceDataset]">
                            <sch:let name="locationContext" value="concat(' | Location &lt;transaction ', string-join(for $att in ancestor-or-self::transaction[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                            <sch:let name="projectId" value="/decor/project/@id"/>
                            <sch:let name="dsid" value="@sourceDataset"/>
                            <sch:let name="dsed" value="@sourceDatasetFlexibility"/>
                            <sch:let name="reffedDataset" value="//datasets/dataset[@id=$dsid][@effectiveDate=$dsed or not($dsed)]"/>
                            <sch:assert role="error" test="not(starts-with($dsid, $projectId)) or count($reffedDataset)&gt;0"
                                >ERROR: <sch:name/>/@sourceDataset='<sch:value-of select="$dsid"/>' MUST point to an existing dataset in the project.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(starts-with($dsid, $projectId)) or not($reffedDataset) or not($dsed) or count($reffedDataset[@effectiveDate=$dsed])&gt;0"
                                >ERROR: <sch:name/>/@sourceDataset='<sch:value-of select="$dsid"/>' / @sourceDatasetFlexibility='<sch:value-of select="$dsed"/>' MUST point to an existing dataset in the project.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="$dsed or count($reffedDataset)&lt;2"
                                >ERROR: <sch:name/>/@sourceDatasetFlexibility SHALL be present when multiple versions of the dataset exist.<sch:value-of select="$locationContext"/></sch:assert>
                            
                            <sch:let name="dsStatus" value="$reffedDataset/@statusCode"/>
                            <sch:let name="dsStatusActive" value="$dsStatus=('new','draft','final','pending')"/>
                            <sch:assert role="warning" test="$dsStatusActive"
                                >WARNING: <sch:name/>/@sourceDataset='<sch:value-of select="$dsid"/>' SHOULD while you may still edit it point to a new, draft, pending or final dataset. Found '<sch:value-of select="$dsStatus"/>'.<sch:value-of select="$locationContext"/></sch:assert>
                            
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:sequence>
                <xs:element name="concept" minOccurs="0" maxOccurs="unbounded" type="ScenarioTemplateConcept"/>
            </xs:sequence>
            <!-- Attributes -->
            <xs:attribute name="ref" type="Oid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a template/@id that sets the structure and rules for the concepts in this representingTemplate.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a template/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="displayName" type="LongDescriptiveName" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Display name for this representingTemplate</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="sourceDataset" type="Oid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a dataset/@id that holds the concept definitions for the concepts in this representingTemplate.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="sourceDatasetFlexibility" type="StaticFlexibility" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a dataset/@effectiveDate that holds the concept definitions for the concepts in this representingTemplate.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
        <xs:unique name="representingTemplate-concepts-unique">
            <xs:selector xpath="./concept"/>
            <xs:field xpath="@ref"/>
        </xs:unique>
    </xs:element>
    <xs:complexType name="ScenarioTemplateConcept">
        <xs:sequence>
            <xs:element name="condition" type="ScenarioTemplateCondition" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="ref" type="Oid" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a concept/@id that is not in history or in a concept list, and is in the dataset that the representing template refers to.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="StaticFlexibility" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a concept/@effectiveDate that is not in history or in a concept list, and is in the dataset that the representing template refers to.
                                                   Note: optional for now, but will be required once the conversion for existing projects is in place.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
        <xs:attribute name="conformance" type="ConformanceType"/>
        <xs:attribute name="isMandatory" type="xs:boolean" default="false"/>
    </xs:complexType>
    <xs:complexType name="ScenarioTemplateCondition" mixed="true">
        <xs:sequence>
            <!-- minOccurs="0" for backwardcompatibility where there was only a text node -->
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
        <xs:attribute name="conformance" type="ConformanceType"/>
        <xs:attribute name="isMandatory" type="xs:boolean" default="false"/>
    </xs:complexType>
    <xs:element name="ids">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="baseId" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="defaultBaseId" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="id" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="identifierAssociation" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
        <xs:key name="id-root">
            <xs:selector xpath="id"/>
            <xs:field xpath="@root"/>
        </xs:key>
    </xs:element>
    <xs:element name="baseId">
        <xs:annotation>
            <xs:documentation xml:lang="nl-NL">baseId stelt een OID branch voor en koppelt een type en weergavenaam aan die branch. Er MOGEN meerdere verschillende baseId's per type zijn. Een OID kan slechts voor één type worden gebruikt. Verdere toelichting op de branch kan door een id met toelichting te creëren.</xs:documentation>
            <xs:documentation xml:lang="en-US">baseId represents an OID branch and associates a type and a display name to that branch. There MAY be multiple different baseId's per type. An OID can only be used for één type. Further explanation for the branch can be added by adding an id with descriptive text.</xs:documentation>
            <xs:documentation xml:lang="de-DE">baseId represents an OID branch and associates a type and a display name to that branch. There MAY be multiple different baseId's per type. An OID can only be used for één type. Further explanation for the branch can be added by adding an id with descriptive text.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate baseId</sch:title>
                        <sch:rule context="baseId">
                            <sch:let name="locationContext" value="concat(' | Location &lt;baseId ', string-join(for $att in @* return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                            
                            <sch:assert role="error" test="substring(@prefix, string-length(@prefix), 1)='-'" sqf:fix="addHyphenToPrefix"
                                >ERROR: A baseId prefix "<sch:value-of select="@prefix"/>" SHALL end with "-".<sch:value-of select="$locationContext"/></sch:assert>
                            
                            <!--<sch:let name="theId" value="@id"/>-->
                            <sch:let name="baseType" value="@type"/>
                            <sch:let name="basePrefix" value="@prefix"/>
                            <!--
                                We're in transition some project will be old style, some new.
                                Old style:
                                    <baseId id="1.2.3" type="DS" prefix="xyz"/>
                                    <defaultBaseId id="1.2.3" type="DS"/>
                                New style:
                                    <baseId id="1.2.3" type="DS" prefix="xyz" default="true"/>
                            -->
                            <!--Support old style-->
                            <sch:assert role="error" test="not(../defaultBaseId) or count(parent::ids/defaultBaseId[@type=$baseType])=1" sqf:fix="addMissingDefaultBaseIds"
                                >ERROR: Exactly one of type '<sch:value-of select="$baseType"/>' SHALL be marked as default base id.<sch:value-of select="$locationContext"/></sch:assert>
                            <!--Support new style-->
                            <sch:assert role="error" test="../defaultBaseId or count(parent::ids/baseId[@type=$baseType][@default='true'])=1"
                                >ERROR: Exactly one of type '<sch:value-of select="$baseType"/>' SHALL be marked with @default='true'.<sch:value-of select="$locationContext"/></sch:assert>
                            
                            <sch:assert role="warning" test="count(../baseId[@prefix = $basePrefix]) = 1"
                                >WARNING: The baseId/@prefix "<sch:value-of select="$basePrefix"/>" with type "<sch:value-of select="$baseType"/>" is not unique. This could lead to ambiguous situations if people use the display version of an id.<sch:value-of select="$locationContext"/></sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:attribute name="id" type="Oid" use="required"/>
            <xs:attribute name="type" type="DecorObjectType" use="required"/>
            <xs:attribute name="prefix" type="ShortDescriptiveName" use="required"/>
            <xs:attribute name="default" type="xs:boolean" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Determines whether or not this baseId is the default for its @type. There SHALL be exactly only one per type with @default='true'</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="defaultBaseId">
        <xs:annotation>
            <xs:documentation xml:lang="nl-NL">defaultBaseId stelt de standaard OID branch voor, voor een bepaalde type. Bij het toekennen van id's aan DECOR objecten wordt deze branch gebruikt als identificatiesysteem. Er MOET exact één defaultBaseId per type zijn. Voor iedere defaultBaseId MOET ook een baseId met hetzelfde type bestaan. Verdere toelichting op de branch kan door een id met toelichting te creëren.</xs:documentation>
            <xs:documentation xml:lang="en-US">defaultBaseId represents the default OID branch for a given type. This branch is used as identifier system in assigning ids to DECOR objects. There SHALL be exactly one defaultBaseId per type. For every defaultBaseId there SHALL also be a baseId with a mtching type. Further explanation for the branch can be added by adding an id with descriptive text.</xs:documentation>
            <xs:documentation xml:lang="de-DE">defaultBaseId represents the default OID branch for a given type. This branch is used as identifier system in assigning ids to DECOR objects. There SHALL be exactly one defaultBaseId per type. For every defaultBaseId there SHALL also be a baseId with a mtching type. Further explanation for the branch can be added by adding an id with descriptive text.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate defaultBaseId type</sch:title>
                        <sch:rule context="defaultBaseId">
                            <sch:let name="locationContext" value="concat(' | Location &lt;defaultBaseId ', string-join(for $att in @* return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                            
                            <sch:let name="dbt" value="@type"/>
                            <sch:assert role="error" test="count(preceding-sibling::defaultBaseId[@type = $dbt])=0"
                                >ERROR: The defaultBaseId type "<sch:value-of select="$dbt"/>" SHALL be unique with project.<sch:value-of select="$locationContext"/></sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:attribute name="id" type="Oid" use="required"/>
            <xs:attribute name="type" type="DecorObjectType" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="id">
        <xs:annotation>
            <xs:documentation xml:lang="nl-NL">Met id geeft u toelichting op diverse ID's in relatie tot het project. Meestal tenminste een betekenis (designation), maar mogelijk ook alleen een koppeling met een bepaalde eigenschap zoals een FHIR URI.</xs:documentation>
            <xs:documentation xml:lang="en-US">With id you give more information about ID related to the project. Usually at least a designation, but potentially also just an association with a property such as a FHIR URI</xs:documentation>
            <xs:documentation xml:lang="de-DE">With id you give more information about ID related to the project. Usually at least a designation, but potentially also just an association with a property such as a FHIR URI</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="designation" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="property" type="ArbitraryPropertyType" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation xml:lang="nl-NL">Id eigenschappen bijvoorbeeld voor het verbinden van dit id met andere typen identificatie (bijv. HL7 FHIR Systeem URI) voor hetzelfde object (codesysteem, OID-tak, identificatiesysteem). Als u van plan bent een HL7 FHIR System URI te verbinden die de voorkeur heeft boven de OID, gebruikt u dan @name='HL7-FHIR-System-URI-Preferred'. Als er wel een HL7 FHIR System URI bestaat maar deze niet de voorkeur heeft boven de OID, gebruikt u dan 'HL7-FHIR-System-URI'. Op deze manier herkent ART-DECOR deze indien van toepassing.</xs:documentation>
                        <xs:documentation xml:lang="en-US">Id properties for example to connect this id to other types of identifiers (e.g. HL7 FHIR System URI) for the same object (code system, OID branch, identification system) If you intend to connect an HL7 FHIR System URI that is preferred over the OID, please use @name='HL7-FHIR-System-URI-Preferred'. When you connect an HL7 FHIR System URI that exists but is not preferred over the OID, please use 'HL7-FHIR-System-URI'. This way ART-DECOR can pick it up if appropriate.</xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="root" use="required" type="Oid"/>
            <xs:attribute name="extension" type="EnumerationString"/>
            <xs:attribute name="assigningAuthority" type="LongDescriptiveName"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="identifierAssociation">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation xml:lang="en-US">identifierAssociation links a dataset concept to an identifier scheme. Any concept may have multiple of these associations</xs:documentation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate identifierAssociation</sch:title>
                        <sch:rule context="identifierAssociation[not(@expirationDate)]">
                            <sch:let name="locationContext" value="concat(' | Location &lt;identifierAssociation ', string-join(for $att in @* return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                            
                            <sch:let name="projectId" value="(//project/@id)[1]"/>
                            <sch:let name="cid" value="@conceptId"/>
                            <sch:let name="ced" value="@conceptFlexibility"/>
                            <sch:let name="thisConcept" value="//datasets//concept[.[@id=$cid][not($ced castable as xs:dateTime) or @effectiveDate] | inherit[@ref=$cid][not($ced castable as xs:dateTime) or @effectiveDate=$ced]][not(ancestor::history | parent::conceptList)]"/>
                            <!-- In inheritance situations from another project, there is no conceptList in this project, so skip check if conceptList id is not from this project -->
                            <sch:assert role="warning" test="$thisConcept"
                                >WARNING: An identifierAssociation SHOULD point to an existing concept. <sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="warning" test="$thisConcept[valueDomain[@type='identifier'] | inherit]"
                                >WARNING: An identifierAssociation SHOULD point to an existing concept with a value domain of type identifier. <sch:value-of select="$locationContext"/></sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <!--<xs:attribute name="id" use="required" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">each assignment MUST have a project unique id so you can attach issues, change with precision, and potentially delete</xs:documentation>
                </xs:annotation>
            </xs:attribute>-->
            <xs:attribute name="conceptId" use="required" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">concept id this assocication is associated with</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="conceptFlexibility" use="optional" type="StaticFlexibility">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">concept effectiveDate this assocication is associated with</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ref" type="Oid" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Object Identifier (OID) of the identification scheme this assocication is associated with. Example: '2.16.840.1.113883.4.1' for US Social Security Numbers</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- version handling -->
            <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
            <!-- removed after talks with users: not relevant for now and a can of worms should want it -->
            <!--<xs:attribute name="statusCode" type="ReleaseStatusCodeLifeCycle" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">manages the status of the association itself</xs:documentation>
                </xs:annotation>
            </xs:attribute>-->
            
            <xs:attributeGroup ref="IdentifierAssociationCompilationAttributes"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="issues">
        <xs:complexType>
            <!--<xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate issues ids</sch:title>
                        <sch:rule context="issue">
                            <sch:let name="iid" value="@id"/>
                            <sch:assert role="error" test="count(preceding-sibling::issue[@id = $iid])=0"
                                >ERROR: issue id '<sch:value-of select="$iid"/>' SHALL be unique with project.<sch:value-of select="$locationContext"/></sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>-->
            <xs:sequence>
                <xs:element ref="labels" minOccurs="0" maxOccurs="1"/>
                <xs:element ref="issue" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="notifier" type="NotifierOnOff" use="optional" default="on">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Specifies whether the automatic notifier system (if activated) should notify all authors of the project about changes of any project issue. Default is "on"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
        <xs:unique name="issue-id-unique">
            <xs:selector xpath="issue"/>
            <xs:field xpath="@id"/>
        </xs:unique>
    </xs:element>
    <xs:simpleType name="NotifierOnOff">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Automatic notifier system (if activated) notifies all authors of the project about changes of any project issue on/off</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="on">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Notificaties aan</xforms:label>
                        <xforms:label xml:lang="en-US">Notifier on</xforms:label>
                        <xforms:label xml:lang="de-DE">Notifier on</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Notifier on</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="off">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Notificaties uit</xforms:label>
                        <xforms:label xml:lang="en-US">Notifier off</xforms:label>
                        <xforms:label xml:lang="de-DE">Notifier off</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Notifier off</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="labels">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Contains definition of labels specific to this DECOR instance. A DECOR instance does require labeling of issues. 
                However once a label is used you SHOULD NOT alter/remove the label.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="label" minOccurs="1" maxOccurs="unbounded" type="IssueLabelDefinition"/>
            </xs:sequence>
        </xs:complexType>
        <xs:unique name="issuelabels-labelcode-unique">
            <xs:selector xpath="label"/>
            <xs:field xpath="@code"/>
        </xs:unique>
    </xs:element>
    <xs:complexType name="IssueLabelDefinition">
        <xs:sequence>
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Describes what the label is meant to represent/do</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="color" type="HTMLColorName" use="optional" default="white">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Contains an HTML compatible reference to a color. Examples for the color red: red, #ff0000, rgb(255,0,0)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="code" type="EnumerationString" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Contains a code that may be used to refer to this label.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="ShortDescriptiveName" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Contains a descriptive name for this label.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:element name="issue">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate tracking/assignment labels</sch:title>
                    <sch:rule context="issue/tracking|issue/assignment">
                        <sch:let name="locationContext" value="concat(' | Location &lt;issue ', string-join(for $att in ancestor::issue[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:let name="labelRef" value="for $lbl in tokenize(@labels,' ') return exists(ancestor::issues[last()]/labels/label[@code=$lbl])"/>
                        <sch:assert role="warning" test="not(@labels) or count(index-of($labelRef,false()))=0">WARNING: Issue <sch:name/> @labels SHOULD reference defined label codes.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <!-- Check event order. Events should be in descending date based order -->
                        <sch:let name="currentDate" value="xs:dateTime(@effectiveDate)"/>
                        <sch:let name="isMaxDate" value="$currentDate = max(($currentDate, preceding-sibling::tracking/xs:dateTime(@effectiveDate), preceding-sibling::assignment/xs:dateTime(@effectiveDate)))"/>
                        <sch:assert role="error" test="$isMaxDate"
                            >ERROR: Issue <sch:name/> SHALL be newer than its preceding events. Issue SHALL occur in descending date order.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="object" minOccurs="0" maxOccurs="unbounded" type="IssueObject"/>
                <xs:choice minOccurs="1" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">The list of historic events in terms of comments tracking and assignments</xs:documentation>
                    </xs:annotation>
                    <xs:element name="tracking" minOccurs="1" maxOccurs="unbounded" type="IssueTracking"/>
                    <xs:element name="assignment" minOccurs="0" maxOccurs="unbounded" type="IssueAssignment"/>
                </xs:choice>
            </xs:sequence>
            <xs:attribute name="id" type="Oid" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The unique id of this issue</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="type" type="IssueType" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The type of this issue</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="priority" type="IssuePriority" use="optional" default="N">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The priority level of this issue, defaults to normal</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="displayName" type="LongDescriptiveName" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A short text to describe the issue (headline)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="IssueType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Kind of issue</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="INC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Storing</xforms:label>
                        <xforms:label xml:lang="en-US">Incident</xforms:label>
                        <xforms:label xml:lang="de-DE">Störung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Incident</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="RFC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Wijzigingsverzoek</xforms:label>
                        <xforms:label xml:lang="en-US">Change Request</xforms:label>
                        <xforms:label xml:lang="de-DE">Änderungswunsch</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Change Request</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="FUT">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Voor de toekomst</xforms:label>
                        <xforms:label xml:lang="en-US">For future consideration</xforms:label>
                        <xforms:label xml:lang="de-DE">Zur zukünftigen Berücksichtigung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">For future consideration</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CLF">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Verduidelijking/toelichting noodzakelijk</xforms:label>
                        <xforms:label xml:lang="en-US">Request for Information/Education</xforms:label>
                        <xforms:label xml:lang="de-DE">Bitte um Information/Aufklärung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Request for Information/Education</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="IssuePriority">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Priority of issue</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="HH">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Hoogste</xforms:label>
                        <xforms:label xml:lang="en-US">Highest</xforms:label>
                        <xforms:label xml:lang="de-DE">Höchste</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Highest</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="H">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Hoog</xforms:label>
                        <xforms:label xml:lang="en-US">High</xforms:label>
                        <xforms:label xml:lang="de-DE">Hoch</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">High</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="N">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Normaal</xforms:label>
                        <xforms:label xml:lang="en-US">Normal</xforms:label>
                        <xforms:label xml:lang="de-DE">Normal</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Normal</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="L">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Laag</xforms:label>
                        <xforms:label xml:lang="en-US">Low</xforms:label>
                        <xforms:label xml:lang="de-DE">Niedrig</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Low</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="LL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Laagst</xforms:label>
                        <xforms:label xml:lang="en-US">Lowest</xforms:label>
                        <xforms:label xml:lang="de-DE">Niedrigste</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Lowest</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="IssueObject">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The object(s) that are subject to the issue</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate issue object</sch:title>
                    <sch:rule context="issue/object">
                        <sch:let name="locationContext" value="concat(' | Location &lt;issue ', string-join(for $att in ancestor::issue[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:assert role="error" test="@id or @name"
                            >ERROR: An issue object SHALL have an id or a name.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="@id or (@name and @flexibility)"
                            >ERROR: If an issue object has only a name, flexibility SHALL be stated.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:attribute name="id" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The id of the object that is subject to the issue; either id or name of the object should be given</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="ShortDescriptiveName" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The name of the object that is subject to the issue; either name or id of the object should be given</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" type="IssueObjectType" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The type of the object that is subject to the issue</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The optional effectiveDate of the object that is subject to the issue</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="IssueObjectType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The type of the object that is subject to an issue</xs:documentation>
        </xs:annotation>
        <xs:restriction base="DecorObjectType">
            <xs:enumeration value="VS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Waardelijst</xforms:label>
                        <xforms:label xml:lang="en-US">Value Set</xforms:label>
                        <xforms:label xml:lang="de-DE">Value Set</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a value set</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een value set</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Value Set</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="DE">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Dataelement</xforms:label>
                        <xforms:label xml:lang="en-US">Data Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Datenelement</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a data element</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een data element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Datenelement</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template</xforms:label>
                        <xforms:label xml:lang="en-US">Template</xforms:label>
                        <xforms:label xml:lang="de-DE">Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a template</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een template</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- KH 20140606: no longer supported 
            <xs:enumeration value="EL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template-element</xforms:label>
                        <xforms:label xml:lang="en-US">Template Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Template-Element</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is an template element</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een template element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Template-Element</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            -->
            <xs:enumeration value="TR">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Transactie</xforms:label>
                        <xforms:label xml:lang="en-US">Transaction</xforms:label>
                        <xforms:label xml:lang="de-DE">Transaktion</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a transaction</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een transactie</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist eine Transaktion</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="DS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Dataset</xforms:label>
                        <xforms:label xml:lang="en-US">Data Set</xforms:label>
                        <xforms:label xml:lang="de-DE">Datensatz</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a data set</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een data set</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Datensatz</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Scenario</xforms:label>
                        <xforms:label xml:lang="en-US">Scenario</xforms:label>
                        <xforms:label xml:lang="de-DE">Szenario</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a scenario</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een scenario</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Szenario</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="IS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Issue</xforms:label>
                        <xforms:label xml:lang="en-US">Issue</xforms:label>
                        <xforms:label xml:lang="de-DE">Issue</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with reference to another issue</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met een relatie naar een ander issue</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt relatiert mit ein Issue</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- 2014-07-16 AH Added -->
            <xs:enumeration value="CS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Codesysteem</xforms:label>
                        <xforms:label xml:lang="en-US">Code system</xforms:label>
                        <xforms:label xml:lang="de-DE">Codesystem</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Code system</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Codesysteem</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Codesystem</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- 2018-03-10 KH Added -->
            <xs:enumeration value="MP">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Concept Map</xforms:label>
                        <xforms:label xml:lang="en-US">Concept Map</xforms:label>
                        <xforms:label xml:lang="de-DE">Concept Map</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Concept Map</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Concept Map</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Concept Map</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="IssueTracking">
        <xs:sequence>
            <xs:element ref="author" minOccurs="1" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The author of this tracking. Every update to a tracking adds a new author marked with an effectiveDate.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="desc" minOccurs="1" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">What is the description or question associated with this tracking</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Identifies the effective date and time of the tracking.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="statusCode" type="IssueStatusCodeLifeCycle" use="required"/>
        <xs:attribute name="labels" type="set_ShortString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">References one or multiple label codes as defined in issues/labels</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="IssueAssignment" mixed="true">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The assignment of an issue to a person or group</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="author" minOccurs="1" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The author of this assignment. Every update to an assignment adds a new author marked with an effectiveDate.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">What is the description or question associated with this assignment</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="to" type="xs:positiveInteger" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Identifier of the person or group where this issue has been assigned to</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="ShortDescriptiveName" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Name / label of the person or group where this issue has been assigned to</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Identifies the effective date and time of the assignment of the issue.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="labels" type="set_ShortString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">References one or multiple label codes as defined in issues/labels</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    
    <xs:element name="templateId">
        <xs:complexType>
            <xs:attribute name="root" type="Oid"/>
            <xs:attribute name="extension" type="EnumerationString"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="NullFlavorPattern">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Null Flavor</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="nullFlavor">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">NullFlavor</xforms:label>
                        <xforms:label xml:lang="nl-NL">NullFlavor</xforms:label>
                        <xforms:label xml:lang="de-DE">NullFlavor</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Null Flavor</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="VocabType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Vocab Type</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="L">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Leaf</xforms:label>
                        <xforms:label xml:lang="nl-NL">Leaf</xforms:label>
                        <xforms:label xml:lang="de-DE">Leaf</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">L Leaf; a term that has no children in the specialization hierarchy, and is selectable, and therefore deemed to be a leaf.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="A">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Abstract</xforms:label>
                        <xforms:label xml:lang="nl-NL">Abstract</xforms:label>
                        <xforms:label xml:lang="de-DE">Abstract</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A Abstract; a term that has children in the specialization hierarchy, but is not, itself, selectable and therefore deemed
                        abstract.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="S">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Specializable</xforms:label>
                        <xforms:label xml:lang="nl-NL">Specializable</xforms:label>
                        <xforms:label xml:lang="de-DE">Specializable</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">S Specializable; a term that has children in the specialization hierarchy, and is also selectable and therefore deemed
                        specializable.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="D">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Deprecated</xforms:label>
                        <xforms:label xml:lang="nl-NL">Deprecated</xforms:label>
                        <xforms:label xml:lang="de-DE">Deprecated</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">D Deprecated; a term that should not be used any longer</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ConformanceType">
        <xs:annotation>
            <xs:appinfo>
                <xforms:label xml:lang="nl-NL">Conformancetype</xforms:label>
                <xforms:label xml:lang="en-US">Conformance Type</xforms:label>
                <xforms:label xml:lang="de-DE">Conformance Typ</xforms:label>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">Conformance Type</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="R">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Required</xforms:label>
                        <xforms:label xml:lang="en-US">Required</xforms:label>
                        <xforms:label xml:lang="de-DE">Required</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">R required</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="C">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Conditioneel</xforms:label>
                        <xforms:label xml:lang="en-US">Conditional</xforms:label>
                        <xforms:label xml:lang="de-DE">Conditional</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">C conditional</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="NP">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Niet aanwezig</xforms:label>
                        <xforms:label xml:lang="en-US">Not present</xforms:label>
                        <xforms:label xml:lang="de-DE">Nicht erlaubt</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">NP not present</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="OidOrNullFlavor">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Allows both OIDs for codesystems or special 'nullFlavor'</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="Oid NullFlavorPattern"/>
    </xs:simpleType>
    <xs:element name="terminology">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="terminologyAssociation" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="codeSystem" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="valueSet" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="conceptAssociation" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
        <!-- Cannot have two valueSets carrying the same id and effectiveDate -->
        <xs:unique name="valueset-idversion-unique">
            <xs:selector xpath="valueSet"/>
            <xs:field xpath="@id"/>
            <xs:field xpath="@effectiveDate"/>
        </xs:unique>
        <xs:unique name="valueset-ref-unique">
            <xs:selector xpath="valueSet"/>
            <xs:field xpath="@ref"/>
        </xs:unique>
        <!-- Cannot have two codeSystems carrying the same id and effectiveDate -->
        <xs:unique name="codesystem-idversion-unique">
            <xs:selector xpath="codeSystem"/>
            <xs:field xpath="@id"/>
            <xs:field xpath="@effectiveDate"/>
        </xs:unique>
        <xs:unique name="codesystem-ref-unique">
            <xs:selector xpath="codeSystem"/>
            <xs:field xpath="@ref"/>
        </xs:unique>
    </xs:element>
    <xs:element name="terminologyAssociation">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation xml:lang="en-US">terminologyAssociation links a concept to a code or a concept list to a value set</xs:documentation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate terminologyAssociation</sch:title>
                        <sch:rule context="terminologyAssociation[not(@expirationDate)]">
                            <sch:let name="locationContext" value="concat(' | Location &lt;terminologyAssociation ', string-join(for $att in @* return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                            
                            <sch:let name="projectId" value="(//project/@id)[1]"/>
                            <sch:let name="deid" value="@conceptId"/>
                            <sch:let name="deed" value="@conceptFlexibility"/>
                            <sch:let name="vsref" value="@valueSet"/>
                            <sch:let name="vsed" value="if (matches(@flexibility,'^\d{4}')) then (@flexibility) else (max(//terminology/valueSet[@id=$vsref or @name=$vsref]/xs:dateTime(@effectiveDate)))"/>
                            <sch:let name="theConcept" value="//datasets//concept[.[@id=$deid][not($deed castable as xs:dateTime) or @effectiveDate] | inherit[@ref=$deid][not($deed castable as xs:dateTime) or @effectiveDate=$deed]][not(ancestor::history | parent::conceptList)]"/>
                            <sch:let name="theConceptList" value="//datasets//valueDomain/conceptList[(@id|@ref)=$deid][not(ancestor::history)]"/>
                            <sch:let name="conceptListConcept" value="//datasets//conceptList/concept[@id=$deid][not(ancestor::history)]"/>
                            <!-- In inheritance situations from another project, there is no conceptList in this project, so skip check if conceptList id is not from this project -->
                            <sch:assert role="warning" test="not($vsref) or $theConceptList or not(starts-with($deid,concat($projectId,'.')))"
                                >WARNING: <sch:name/>/@conceptId='<sch:value-of select="$deid"/>' SHOULD point to an existing conceptList.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="if (@code and starts-with($deid, concat($projectId,'.'))) then ($theConcept | $conceptListConcept) else (true())"
                                >ERROR: <sch:name/>/@conceptId='<sch:value-of select="$deid"/>' SHOULD point to an existing concept or concept within a conceptList.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="warning" test="if (@code and not(starts-with($deid,concat($projectId,'.')))) then ($theConcept | $conceptListConcept) else (true())"
                                >WARNING: <sch:name/>/@conceptId='<sch:value-of select="$deid"/>' SHOULD point to an existing concept or concept within a conceptList.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@strength) or @strength = 'required' or $vsref"
                                >ERROR: <sch:name/>/@conceptId='<sch:value-of select="$deid"/>' SHOULD NOT specify a binding strength unless it concerns a value set binding.<sch:value-of select="$locationContext"/></sch:assert>
                            
                            <sch:assert role="error" test="if ($vsref and (starts-with($vsref, concat($projectId,'.')) or ancestor::decor[@versionDate])) then //terminology/valueSet[(@id|@ref|@name)=$vsref][@ref or @effectiveDate=$vsed] else (true())"
                                >ERROR: <sch:name/>/@conceptId='<sch:value-of select="$deid"/>' SHALL point to an existing valueSet '<sch:value-of select="$vsref"/>' and if applicable with the correct @flexibility.<sch:value-of select="if (ancestor::decor[@versionDate]) then (' In a compiled project, all references are expected to be resolved.') else (' The artifact would appear to be part of your project based on id. It might be resolved during pre-publication compile phase, regardless of a reference, but they will not be in your list of artifacts in ART while there is no reference.')"/><sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="info" test="if ($vsref and not(starts-with($vsref, concat($projectId,'.')) or ancestor::decor[@versionDate])) then //terminology/valueSet[(@id|@ref|@name)=$vsref][@ref or @effectiveDate=$vsed] else (true())"
                                >INFO: <sch:name/>/@conceptId='<sch:value-of select="$deid"/>' SHOULD point to an existing valueSet '<sch:value-of select="$vsref"/>' and if applicable with the correct @flexibility. Note that in the pre-publication compile phase these references will be resolved if possible, regardless of a reference, but they will not be in your list of artifacts in ART while there is no reference.<sch:value-of select="$locationContext"/></sch:assert>
                            
                            <sch:assert role="error" test="@code or $vsref"
                                >ERROR: <sch:name/>/@conceptId='<sch:value-of select="$deid"/>' SHALL have a @code or a @valueSet.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@code and $vsref)"
                                >ERROR: <sch:name/>/@conceptId='<sch:value-of select="$deid"/>' SHALL NOT have both @code and @valueSet.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="error" test="not(@code and $vsref)"
                                >ERROR: <sch:name/>/@conceptId='<sch:value-of select="$deid"/>' SHALL NOT have both @code '<sch:value-of select="@code"/>' and @flexibility.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="warning" test="not($vsref) or matches($vsref,'^[0-9\.]+$')"
                                >WARNING: <sch:name/>/@valueSet='<sch:value-of select="$vsref"/>' references SHOULD be based on valueSet/@id. References by @name quickly become ambiguous.<sch:value-of select="$locationContext"/></sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <!--<xs:attribute name="id" use="optional" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">each assignment SHOULD have a project unique id so you can attach issues, manage the status machine, change with precision, and potentially delete</xs:documentation>
                </xs:annotation>
            </xs:attribute>-->
            <!-- concept id where this assocication is associated with -->
            <xs:attribute name="conceptId" use="required" type="Oid"/>
            <xs:attribute name="conceptFlexibility" use="optional" type="StaticFlexibility">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Refers to the concept/@effectiveDate if conceptId points to a real concept and not to conceptList or a concept under a conceptList.</xs:documentation>
                </xs:annotation>
            </xs:attribute>

            <!-- a coded concept -->
            <xs:attribute name="code" use="optional" type="EnumerationString"/>
            <xs:attribute name="codeSystem" use="optional" type="Oid"/>
            <!-- human readable things for codes -->
            <xs:attribute name="codeSystemName" use="optional" type="NonEmptyString"/>
            <xs:attribute ref="displayName" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A displayname for the code, only for human readablility here</xs:documentation>
                </xs:annotation>
            </xs:attribute>

            <!-- a value set and flexibility -->
            <xs:attribute name="valueSet" type="BasicIdOrOid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a valueSet/@id or @name. References to @name are discouraged because they become ambiguous quickly.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a valueSet/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- coding strength -->
            <xs:attribute name="strength" type="CodingStrengthType" default="required" use="optional"/>
            
            <!-- version handling -->
            <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
            <!-- removed after talks with users: not relevant for now and a can of worms should want it -->
            <!--<xs:attribute name="statusCode" type="ReleaseStatusCodeLifeCycle" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">manages the status of the association itself</xs:documentation>
                </xs:annotation>
            </xs:attribute>-->
            
            <xs:attribute name="equivalence" type="EquivalencyType" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Rating of mapping between the concept to the associated code or a concept list to an associated value set</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- Only relevant after compilation -->
            <xs:attributeGroup ref="TerminologyAssociationCompilationAttributes"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="conceptAssociation">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Concept association is for mapping between coded concepts in value sets or between concepts in datasets</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="desc" minOccurs="0" maxOccurs="1" type="FreeFormMarkupWithLanguage"/>
                <xs:element name="source" minOccurs="1" maxOccurs="1" type="SourceOrTargetValueSet"/>
                <xs:element name="target" minOccurs="1" maxOccurs="1" type="SourceOrTargetValueSet"/>
                <xs:element name="group" minOccurs="1" maxOccurs="unbounded" type="ConceptMapGroupDefinition"/>
            </xs:sequence>
            <xs:attribute name="id" type="Oid" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Defines the globally unique identifier for this concept map.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute ref="displayName" use="required"/>
            <xs:attributeGroup ref="VersionHandling"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="optional"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="SourceOrTargetValueSet">
        <xs:attribute name="ref" type="Uri" use="required"/>
        <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic"/>
        <xs:attribute ref="displayName" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">A displayname for the object, only for human readablility here</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="ConceptMapGroupDefinition">
        <xs:sequence>
            <xs:element name="source" minOccurs="1" maxOccurs="1" type="SourceOrTargetCodeSystem"/>
            <xs:element name="target" minOccurs="1" maxOccurs="1" type="SourceOrTargetCodeSystem"/>
            <xs:element name="element" minOccurs="1" maxOccurs="unbounded" type="ConceptMapElement"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="SourceOrTargetCodeSystem">
        <xs:attribute name="codeSystem" type="Oid" use="required"/>
    </xs:complexType>
    <xs:complexType name="ConceptMapElement">
        <xs:sequence>
            <xs:element name="target" minOccurs="1" maxOccurs="unbounded" type="ConceptMapTarget"/>
        </xs:sequence>
        <xs:attribute name="code" type="EnumerationString" use="required"/>
        <xs:attribute ref="displayName" use="optional"/>
    </xs:complexType>
    <xs:complexType name="ConceptMapTarget">
        <xs:sequence>
            <xs:element name="equivalence" minOccurs="1" maxOccurs="unbounded" type="EquivalencyTypeDefinition"/>
            <xs:element name="comment" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="code" type="EnumerationString" use="required"/>
        <xs:attribute ref="displayName" use="optional"/>
    </xs:complexType>
    <xs:complexType name="EquivalencyTypeDefinition">
        <xs:attribute name="code" type="EquivalencyType" use="required"/>
    </xs:complexType>
    <xs:element name="valueSet">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Value Set. A DECOR valueSet can take different forms. It may be a simple value set reference (@ref) to a value set from a repository without any contents, id, effectiveDate or statusCode, but with a name and a displayName. The other option is a valueSet with contents, id, effectiveDate, statusCode, name and displayName.</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate value set object</sch:title>
                    <sch:rule context="terminology/valueSet[not(@statusCode=('deprecated','cancelled','rejected'))]">
                        <sch:let name="locationContext" value="concat(' | Location &lt;valueSet ', string-join(for $att in ancestor-or-self::valueSet[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:assert role="error" test="(@id and @effectiveDate) or @ref"
                            >ERROR: <sch:name/> SHALL have an @id and @effectiveDate, or a @ref.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@id and @ref)"
                            >ERROR: <sch:name/> SHALL NOT have both @id and @ref.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@canonicalUri and @ref)"
                            >ERROR: <sch:name/> SHALL NOT have both @canonicalUri and @ref.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:assert role="error" test="@ref or (@id and (conceptList/(concept|include[not(string(@exception)='true')]) or completeCodeSystem))"
                            >ERROR: <sch:name/> SHALL have conceptList with concepts or completeCodeSystem.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@ref and (@*[not(name()=('ref','flexibility','name','displayName'))] or conceptList or completeCodeSystem))"
                            >ERROR: <sch:name/> with a @ref SHALL NOT have other attributes than @name or @displayName or have a conceptList or completeCodeSystem.<sch:value-of select="$locationContext"/></sch:assert>
                        <!--<sch:assert test="not(completeCodeSystem and conceptList/(concept|include[not(string(@exception)='true')]))">ERROR: Value set MUST NOT reference codeSystems AND concepts.<sch:value-of select="$locationContext"/></sch:assert>-->
                        <sch:assert role="error" test="(@id and @effectiveDate) or @ref"
                            >ERROR: <sch:name/> with a @id SHALL have an @effectiveDate.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:assert role="error" test="not(.//concept[@codeSystem = '2.16.840.1.113883.5.1008'] | .//include[@ref = '2.16.840.1.113883.1.11.10609'][not(@exception = 'true')]) or .[@id = '2.16.840.1.113883.1.11.10609']"
                            >ERROR: <sch:name/> SHALL NOT contain NullFlavor codes as concepts. NullFlavor SHALL be exception.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                    <sch:rule context="terminology/valueSet[not(@statusCode=('deprecated','cancelled','rejected'))]/conceptList/exception">
                        <sch:let name="locationContext" value="concat(' | Location &lt;valueSet ', string-join(for $att in ancestor-or-self::valueSet[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:let name="theCode" value="@code"/>
                        <sch:let name="theCodeSystem" value="@codeSystem"/>
                        <sch:assert role="error" test="not(preceding-sibling::exception[@code=$theCode][@codeSystem=$theCodeSystem])"
                            >ERROR: <sch:name/> exception "<sch:value-of select="$theCode"/>" SHALL be unique within the same value set.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
                <!-- Only relevant after compilation -->
                <xs:group ref="ValueSetCompilationSourceCodeSystem"/>
                <!-- 
                    there may be one publishing and one or more endorsing authorities
                    not used by DECOR yet, but is populated by the ValueSet API upon retrieval based on the first project/copyright
                -->
                <xs:element name="publishingAuthority" type="AuthorityType" minOccurs="0" maxOccurs="1">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">The authoritative body who has reviewed the Value set for (clinical) accuracy and relevance, 
                            and authorized it for publication. Registries may require this element to be valued</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="endorsingAuthority" type="AuthorityType" minOccurs="0" maxOccurs="0">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">A list of bodies who have reviewed the Value set for (clinical) accuracy and relevance, and endorsed it for use</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- FHIR Value Set DSTUr1 0.8 compatibility -->
                <xs:element name="purpose" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">A statement about the purpose of the template</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="copyright" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">A copyright statement relating to the template and/or its contents.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- 
                    there may be 0..* value set revision history discriptions
                    not used by DECOR yet
                -->
                <xs:element name="revisionHistory" type="ObjectHistory" minOccurs="0" maxOccurs="0">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">The free text description describing the changes in this version of the Value set
                            as compared to the previous version. Since Value set versions are built off of previous versions, the net effect 
                            of this field is to function as a comprehensive historical reference of the Value set.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="completeCodeSystem" type="CodeSystemReference" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="conceptList" type="ValueSetConceptList" minOccurs="0" maxOccurs="1"/>
            </xs:sequence>
            <xs:attribute name="id" type="Oid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Defines the globally unique identifier for this value set and may be used to reference it. Value sets SHOULD carry either @id or @ref</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute ref="canonicalUri" use="optional"/>
            <xs:attribute name="ref" type="Oid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a valueSet/@id. Value sets SHALL carry either @id or @ref</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="name" use="required" type="BasicId"/>
            <xs:attribute ref="displayName" use="required"/>
            <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="optional"/>
            
            <!-- if @ref, flexibility -->
            <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a valueSet/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- Only relevant after compilation -->
            <xs:attributeGroup ref="ValueSetCompilationAttributes"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="CodeSystemReference">
        <xs:attribute name="codeSystem" type="Oid" use="required"/>
        <xs:attribute name="codeSystemName" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Display name for the code system as it is known in your context. This may or may not be the official name for the code system.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="codeSystemVersion" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Version string for the code system. This is only relevant for code systems with incompatible versions. If specified, than your instances will need to carry this information exactly as-is.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a codeSystem/@codeSystemVersion. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="ValueSetConceptList">
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="concept" type="ValueSetConcept"/>
                <xs:element name="include" type="ValueSetRefOrIntensionalOp"/>
                <xs:element name="exclude" type="ValueSetRefOrIntensionalOp"/>
            </xs:choice>
            <xs:element name="exception" type="ValueSetConcept" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="ValueSetConcept">
        <xs:sequence>
            <xs:element ref="designation" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">You may add a description for convenience, but should note that most of the time the description here overlaps with the designation/description of the coded concept</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="code" type="EnumerationString" use="required"/>
        <xs:attribute name="codeSystem" type="Oid" use="required"/>
        <xs:attribute name="codeSystemName" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Display name for the code system as it is known in your context. This may or may not be the official name for the code system.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="codeSystemVersion" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Version string for the code system. This is only relevant for code systems with incompatible versions. If specified, than your instances will need to carry this information exactly as-is.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute ref="displayName" use="required"/>
        <xs:attribute name="ordinal" type="IntegerOrDecimalRange">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Relevant for codes in an ordinal system, like Glasgow Coma Scale, to reflect the order of the code in the set.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="level" type="xs:integer" use="required"/>
        <xs:attribute name="type" type="VocabType" use="required"/>
    </xs:complexType>
    <xs:complexType name="ValueSetRefOrIntensionalOp">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate value set concept list include and exclude statements</sch:title>
                    <sch:rule context="terminology/valueSet[not(@statusCode=('deprecated','cancelled','rejected'))]/conceptList/include | terminology/valueSet[not(@statusCode=('deprecated','cancelled','rejected'))]/conceptList/exclude">
                        <sch:let name="locationContext" value="concat(' | Location &lt;valueSet ', string-join(for $att in ancestor-or-self::valueSet[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        <sch:assert role="error" test="not((@ref or @flexibility[not(. = 'dynamic')] or @exception[not(. = 'false')]) and (@op or @code or @codeSystem))"
                            >ERROR: <sch:name/> SHALL have @ref, @flexibility, @exception or @op, @code, @codeSystem.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        <xs:documentation xml:lang="en-US">Either a value set ref or an operator op with code, codeSystem and displayName. Include is of another valueSet, typically from a repository, but potentially within the same DECOR definition.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">You may add a description for convenience, but should note that most of the time the description here overlaps with the description of the referenced value set / intensional definition</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <!-- 
            value set ref
        -->
        <xs:attributeGroup ref="ValueSetRefAttributes"/>
        <!-- Only relevant after compilation -->
        <xs:attributeGroup ref="ValueSetCompilationAttributes"/>
        <!-- 
            intensional definition
        -->
        <xs:attributeGroup ref="IntensionalDefAttributes"/>
    </xs:complexType>
    <xs:attributeGroup name="ValueSetRefAttributes">
        <xs:attribute name="ref" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a valueSet/@id.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a valueSet/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="exception" use="optional" type="xs:boolean" default="false">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Indicates whether the valueSet contents should be treated as exceptions. Default is 'false' meaning that the contents are included as concepts.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="IntensionalDefAttributes">
        <xs:attribute name="op" type="IntensionalOperators" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Intensional Definition</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="code" type="EnumerationString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">An identifier that uniquely names the class or "concept" within the context of the defining Code System</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="codeSystem" type="Oid" use="optional"/>
        <xs:attribute ref="displayName" use="optional"/>
    </xs:attributeGroup>
    <xs:simpleType name="IntensionalOperators">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="is-a">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">is-a</xforms:label>
                        <xforms:label xml:lang="nl-NL">is-a</xforms:label>
                        <xforms:label xml:lang="de-DE">is-a</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">is-a or &lt;&lt; :: includes all concept ids that have a transitive is-a relationship with the concept Id provided as the value, including the provided concept itself (i.e. include child codes)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="descendent-of">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">descendant-of</xforms:label>
                        <xforms:label xml:lang="nl-NL">descendant-of</xforms:label>
                        <xforms:label xml:lang="de-DE">descendant-of</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">descendant-of or &lt; :: includes all concept ids that have a transitive is-a relationship with the concept Id provided as the value, excluding the provided concept itself (i.e. include child codes)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="is-not-a">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">is-not-a</xforms:label>
                        <xforms:label xml:lang="nl-NL">is-not-a</xforms:label>
                        <xforms:label xml:lang="de-DE">is-not-a</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">is-not-a :: the specified property of the code does not have an is-a relationship with the provided value</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="regex">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">regex</xforms:label>
                        <xforms:label xml:lang="nl-NL">regex</xforms:label>
                        <xforms:label xml:lang="de-DE">regex</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">regex :: the specified property of the code matches the regex specified in the provided value</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="codeSystem">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Code system</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate code system object</sch:title>
                    <sch:rule context="terminology/codeSystem">
                        <sch:let name="locationContext" value="concat(' | Location &lt;codeSystem ', string-join(for $att in (@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:assert role="error" test="(@id and @effectiveDate) or @ref"
                            >ERROR: <sch:name/> SHALL have an @id and @effectiveDate, or a @ref.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@id and @ref)"
                            >ERROR: <sch:name/> SHALL NOT have both @id and @ref.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@canonicalUri and @ref)"
                            >ERROR: <sch:name/> SHALL NOT have both @canonicalUri and @ref.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:assert role="error" test="@ref or (@id and (conceptList or *[local-name() = 'CodeSystem'] ))"
                            >ERROR: <sch:name/> with a @id SHALL have a conceptList or a fhir:CodeSystem.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">A description that describes the Code System</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:choice maxOccurs="1">
                    <xs:element name="conceptList" type="CodeSystemConceptList" minOccurs="0" maxOccurs="1"/>
                    <!-- or FHIR code system positioned temporarily here -->
                    <xs:any namespace="http://hl7.org/fhir" minOccurs="0" maxOccurs="1" processContents="skip"/>
                </xs:choice>
            </xs:sequence>
            <xs:attribute name="id" use="optional" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A version identifier that uniquely identifies each version of a Code System</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute ref="canonicalUri" use="optional"/>
            <xs:attribute name="ref" type="Oid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A reference to a version identifier of a Code System</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="name" use="required" type="BasicId"/>
            <xs:attribute ref="displayName" use="required"/>
            <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="optional"/>
            
            <!-- if @ref, flexibility -->
            <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a codeSystem/@codeSystem. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- Only relevant after compilation -->
            <xs:attributeGroup ref="CodeSystemCompilationAttributes"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="CodeSystemConceptList">
        <xs:sequence>
            <xs:element ref="codedConcept" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:element name="codedConcept">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="designation" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">A language symbol for the concept that is intended to convey the concept meaning to a human being. It may contain multiple designations per
                            language to expres preferences, synonyms etc. For example, in SNOMED CT, the concept of "fever" has the fully specified name of "fever (finding)", a preferred name of
                            "fever", and synonyms of "febrile" and "pyrexia". These are all designations in English for the concept of "fever".</xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="code" type="EnumerationString" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">An identifier that uniquely names the class or "concept" within the context of the defining Code System</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="statusCode" type="NonEmptyString" use="optional" default="active">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Status of the "concept", in this context only "active" concepts are listed</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="level" type="xs:integer" use="required"/>
            <xs:attribute name="type" type="VocabType" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="designation">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation xml:lang="en-US">A description for the designation</xs:documentation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate FreeFormMarkupWithLanguage designation</sch:title>
                        <sch:rule context="designation[not(ancestor::example)]">
                            <sch:let name="locationContext" value="concat(' | Location &lt;',name(parent::*),' ', string-join(for $att in parent::*/@* return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                            
                            <sch:assert role="error" test="not(preceding-sibling::*[name()=name(current())][@language=current()/@language][@type='preferred' and current()/@type='preferred'])"
                                >ERROR: Each repetition of <sch:value-of select="name(..)"/>/<sch:name/> with language SHALL be a different language, or only one SHALL be marked 'preferred'.<sch:value-of select="$locationContext"/></sch:assert>
                            <sch:assert role="warning" test="@language"
                                >WARNING: Each repetition of <sch:value-of select="name(..)"/>/<sch:name/> SHOULD be qualified with @language.<sch:value-of select="$locationContext"/></sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:complexContent>
                <xs:extension base="FreeFormMarkupWithLanguageCode">
                    <xs:attribute name="type" type="DesignationType" use="optional">
                        <xs:annotation>
                            <xs:documentation xml:lang="en-US">Type of designation (for that language), preferred, synonym, abbreviation, fully specified name</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute ref="displayName" use="required">
                        <xs:annotation>
                            <xs:documentation xml:lang="en-US">A short description string for the designation</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="DesignationType">
        <xs:annotation>
            <xs:documentation>Details of how a designation would be used, see also http://hl7.org/fhir/ValueSet/designation-use (2.16.840.1.113883.4.642.3.259), extended</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="preferred">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">preferred</xforms:label>
                        <xforms:label xml:lang="nl-NL">preferent</xforms:label>
                        <xforms:label xml:lang="de-DE">bevorzugt</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">preferred</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="synonym">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">synonym</xforms:label>
                        <xforms:label xml:lang="nl-NL">synoniem</xforms:label>
                        <xforms:label xml:lang="de-DE">Synonym</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">synonym</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="abbreviation">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">abbreviation</xforms:label>
                        <xforms:label xml:lang="nl-NL">afkorting</xforms:label>
                        <xforms:label xml:lang="de-DE">Abkürzung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">abbreviation</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="fsn">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">fully specified name</xforms:label>
                        <xforms:label xml:lang="nl-NL">volledig gespecificeerde naam</xforms:label>
                        <xforms:label xml:lang="de-DE">vollständig spezifizierter Name</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">fully specified name</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- for later release
            <xs:enumeration value="patientfriendly">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">patient-friendly</xforms:label>
                        <xforms:label xml:lang="nl-NL">patiëntvriendelijk</xforms:label>
                        <xforms:label xml:lang="de-DE">patientenfreundlich</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">patient-friendly</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            -->
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="EquivalencyType">
        <xs:annotation>
            <xs:documentation>Details of how two concepts map to each other, the source is : relatedto | equivalent | equal | wider | subsumes | narrower | specializes | inexact | unmatched | disjoint; See also FHIR ConceptMapEquivalence http://hl7.org/fhir/concept-map-equivalence; Releationship with "ISO/TR 12300:2014 Health informatics, Principles of mapping between terminological systems" is also indicated</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="relatedto">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">related to</xforms:label>
                        <xforms:label xml:lang="nl-NL">gerelateerd aan</xforms:label>
                        <xforms:label xml:lang="de-DE">verwandt mit</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">The concepts are related to each other, and have at least some overlap in meaning, but the exact relationship is not known</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="equivalent">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">equivalent</xforms:label>
                        <xforms:label xml:lang="nl-NL">gelijkwaardig</xforms:label>
                        <xforms:label xml:lang="de-DE">äquivalent</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">The definitions of the concepts mean the same thing (including when structural implications of meaning are considered) (i.e. extensionally identical). / ISO 12300: 2 = Equivalence of meaning, but with synonymy. For example, ureteric calculus and ureteric stone; gall stones and cholelithiasis.
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="equal">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">equal</xforms:label>
                        <xforms:label xml:lang="nl-NL">gelijk</xforms:label>
                        <xforms:label xml:lang="de-DE">gleich</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">The definitions of the concepts are exactly the same (i.e. only grammatical differences) and structural implications of meaning are identical or irrelevant (i.e. intentionally identical). / ISO 12300: 1 = Equivalence of meaning; lexical, as well as conceptual. For example, asthma and asthma; ovarian cyst and cyst of ovary.
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="wider">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">wider</xforms:label>
                        <xforms:label xml:lang="nl-NL">breder</xforms:label>
                        <xforms:label xml:lang="de-DE">breiter</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">The target mapping is wider in meaning than the source concept. / ISO 12300: 3 = Source concept is broader and has a less specific meaning than the target concept/term. For
                        example, obesity and morbid obesity; diabetes and diabetes mellitus type II.
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="subsumes">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">subsumes</xforms:label>
                        <xforms:label xml:lang="nl-NL">omvat</xforms:label>
                        <xforms:label xml:lang="de-DE">umfasst</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">The target mapping subsumes the meaning of the source concept (e.g. the source is-a target).</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="narrower">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">narrower</xforms:label>
                        <xforms:label xml:lang="nl-NL">nauwer</xforms:label>
                        <xforms:label xml:lang="de-DE">enger</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">The target mapping is narrower in meaning than the source concept. The sense in which the mapping is narrower SHALL be described in the comments in this case, and applications should be careful when attempting to use these mappings operationally. / ISO 12300: 4 = Source concept is narrower and has a more specific meaning than the target concept/term. For example, feels ugly and self-image finding; acute renal failure syndrome secondary to dehydration and acute renal failure syndrome.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="specializes">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">specializes</xforms:label>
                        <xforms:label xml:lang="nl-NL">specialiseert</xforms:label>
                        <xforms:label xml:lang="de-DE">spezialisiert</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">The target mapping specializes the meaning of the source concept (e.g. the target is-a source).</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="inexact">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">inexact</xforms:label>
                        <xforms:label xml:lang="nl-NL">onnauwkeurig</xforms:label>
                        <xforms:label xml:lang="de-DE">ungenau</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">The target mapping overlaps with the source concept, but both source and target cover additional meaning, or the definitions are imprecise and it is uncertain whether they have the same boundaries to their meaning. The sense in which the mapping is narrower SHALL be described in the comments in this case, and applications should be careful when attempting to use these mappings operationally.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="unmatched">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">unmatched</xforms:label>
                        <xforms:label xml:lang="nl-NL">onvergelijkelijk</xforms:label>
                        <xforms:label xml:lang="de-DE">unvergleichbar</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">There is no match for this concept in the destination concept system. / ISO 12300: 5 = No map is possible. No concept was found in the target with some degree of equivalence (as
                        measured by any of the other four ratings).</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="disjoint">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">disjoint</xforms:label>
                        <xforms:label xml:lang="nl-NL">elkaar uitsluitend</xforms:label>
                        <xforms:label xml:lang="de-DE">sich auschließend</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This is an explicit assertion that there is no mapping between the source and target concept.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!--
            <xs:enumeration value="unrated">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">unrated</xforms:label>
                        <xforms:label xml:lang="nl-NL">onbeoordeeld</xforms:label>
                        <xforms:label xml:lang="de-DE">nicht beurteilt</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">The mapping between source and target concept is not (yet) rated.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            -->
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="rules">
        <xs:complexType>
            <xs:choice maxOccurs="unbounded">
                <xs:element name="templateAssociation" type="TemplateAssociationDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="template" type="TemplateDefinition" minOccurs="0" maxOccurs="unbounded">
                    <xs:unique name="templateversion-node-id-unique">
                        <xs:selector xpath=".//element | .//attribute"/>
                        <xs:field xpath="@id"/>
                    </xs:unique>
                </xs:element>
                <xs:element name="structuredefinition" type="StructureDefinition" minOccurs="0" maxOccurs="unbounded"/>
            </xs:choice>
        </xs:complexType>
        <!-- Cannot have two templates carrying the same id and effectiveDate -->
        <xs:unique name="template-idversion-unique">
            <xs:selector xpath="template"/>
            <xs:field xpath="@id"/>
            <xs:field xpath="@effectiveDate"/>
        </xs:unique>
        <xs:unique name="template-ref-unique">
            <xs:selector xpath="template"/>
            <xs:field xpath="@ref"/>
        </xs:unique>
        <!-- Cannot have two templateAssociations for the same template (based on id and effectiveDate) -->
        <xs:unique name="templateAssociation-idversion-unique">
            <xs:selector xpath="templateAssociation"/>
            <xs:field xpath="@templateId"/>
            <xs:field xpath="@effectiveDate"/>
        </xs:unique>
        <!-- Cannot have two structuredefinitions carrying the same canonicalUri and version -->
        <xs:unique name="structuredefinition-uri-version-unique">
            <xs:selector xpath="structuredefinition"/>
            <xs:field xpath="@canonicalUri"/>
            <xs:field xpath="@version"/>
        </xs:unique>
        <!-- Cannot have two structuredefinitions carrying the same internalId -->
        <xs:unique name="structuredefinition-internal-unique">
            <xs:selector xpath="structuredefinition"/>
            <xs:field xpath="@id"/>
        </xs:unique>
    </xs:element>
    <xs:complexType name="StructureDefinition">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Structure definition reference: associates logical model/dataset concepts to a FHIR StructureDefinition, and holds enough information to fetch the associated StructureDefinition. The StructureDefinition is expected to 'live' in the localhost FHIR package, or on a remote server.</xs:documentation>
            <!--<xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Template Association Concept</sch:title>
                    <sch:rule context="structuredefinition">
                        <sch:let name="locationContext" value="concat(' | Location &lt;structuredefinition ', string-join(for $att in @* return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:let name="referencedFrom" value="@referencedFrom"/>
                        <sch:let name="bbrList" value="//project/buildingBlockRepository[@type = 'FHIR']"/>
                        
                        <sch:assert role="error" test="not($referencedFrom) or $bbrList[@ident = $referencedFrom]"
                            >ERROR: <name/>/@referencedFrom (<sch:value-of select="$referencedFrom"/> SHALL match the @ident of one of the project buildingBlockRepositories.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>-->
            <xs:appinfo>
                <xforms:label xml:lang="nl-NL">StructureDefinition</xforms:label>
                <xforms:label xml:lang="en-US">StructureDefinition</xforms:label>
                <xforms:label xml:lang="de-DE">StructureDefinition</xforms:label>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="concept" type="TemplateAssociationConcept" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="publicationUrl" type="xs:anyURI" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The URL to retrieve this StructureDefinition from, including any query parameters like ?version=... if necessary.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute ref="canonicalUri" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">FHIR canonical URI for this StructureDefinition. Relevant when the publication url fails.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="id" type="Uuid" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The internal id of this element for referencing</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strucdefId" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to the [base]/StructureDefinition/[id] that this association is referring to</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strucdefVersion" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to the [base]/StructureDefinition/[id]/_history/[version] that this association is referring to. Assumption to always talk about the most current revision, and that new versions of the StructureDefinition are stored under a new id</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute ref="displayName" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to the StructureDefinition/name or ./title. It's main purpose here is to provide some optimization in list/search retrieval</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <!--<xs:attribute name="internalId" type="Uuid" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The internal id for the structure definition reference</xs:documentation>
            </xs:annotation>
        </xs:attribute>-->
        <xs:attribute name="referencedFrom" type="ShortDescriptiveName" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The ident of the repository where this StructureDefinition resides. Must match one of the buildingBlockRepository idents of type FHIR</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="TemplateAssociationDefinition">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate Template Association Definition</sch:title>
                    <!-- <templateAssociation templateId="2.16.840.1.113883.2.4.6.10.100.13" effectiveDate="2012-05-09T00:00:00"> -->
                    <sch:rule context="templateAssociation">
                        <sch:let name="locationContext" value="concat(' | Location &lt;',name(),' ', string-join(for $att in @* return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:let name="tmid" value="@templateId"/>
                        <sch:let name="tmed" value="@effectiveDate"/>
                        <sch:assert role="error" test="//rules/(template[@id=$tmid][@effectiveDate=$tmed] | template[@ref=$tmid])"
                            >ERROR: A template association SHALL be bound with a template with the same id '<sch:value-of select="$tmid"/>' and effectiveDate '<sch:value-of select="$tmed"/>'.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:assert role="error" test="count(../templateAssociation[@templateId=$tmid][@effectiveDate=$tmed]) le 1"
                            >ERROR: There SHALL be 0..1 template association per template (<sch:value-of select="$tmid"/> - <sch:value-of select="$tmed"/>).<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="concept" type="TemplateAssociationConcept" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="templateId" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to the template/@id where this template association is referring to</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to the template/@effectiveDate where this template association is referring to (should 
                    actually be named templateEffectiveDate according to the other attribute @templateId</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="TemplateAssociationConcept">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate Template Association Concept</sch:title>
                    <!-- <concept ref="2.16.840.1.113883.2.4.3.11.60.100.2.4.472" effectiveDate="2012-05-20T14:12:37" elementId="2.16.840.1.113883.2.4.3.11.60.100.9.13.2"/> -->
                    <sch:rule context="templateAssociation/concept">
                        <sch:let name="locationContext" value="concat(' | Location &lt;templateAssociation ', string-join(for $att in ancestor::templateAssociation/(@templateId, @effectiveDate) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:let name="tmid" value="parent::templateAssociation/@templateId"/>
                        <sch:let name="tmed" value="parent::templateAssociation/@effectiveDate"/>
                        <sch:let name="deid" value="@ref"/>
                        <sch:let name="deed" value="@effectiveDate"/>
                        <sch:let name="theConcept" value="//datasets//concept[@id = $deid][@effectiveDate = $deed][not(ancestor::history)]"/>
                        <sch:let name="theConcepts" value="//datasets//concept[@id = $deid][not(ancestor::history)]"/>
                        <sch:let name="theNewestConcept" value="max($theConcepts/xs:dateTime(@effectiveDate))"/>
                        <sch:let name="theConceptIsNewest" value="$theConcept/@effectiveDate = $theNewestConcept"/>
                        <sch:let name="elid" value="@elementId"/>
                        <sch:let name="templateIsRef" value="ancestor::rules/template[@ref=$tmid]"/>
                        <sch:let name="theTemplate" value="ancestor::rules/template[@id=$tmid][@effectiveDate=$tmed]"/>
                        <sch:let name="theElement" value="$theTemplate//*[@id=$elid]"/>
                        <sch:assert role="info" test="$theTemplate[@statusCode=('cancelled','rejected','retired')] or $theConcept"
                            >INFO: A template association concept SHOULD be bound to a concept with same id '<sch:value-of select="$deid"/>' and (if indicated) effectiveDate '<sch:value-of select="$deed"/>'.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="$theTemplate[@statusCode=('cancelled','rejected','retired')] or $theElement or $templateIsRef"
                            >ERROR: A template association concept SHALL be bound to an element with the indicated id '<sch:value-of select="$elid"/>' in the indicated template with the same id and effectiveDate.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:let name="termAssocsConcept" value="//terminologyAssociation[@conceptId = $theConcept/@id][@conceptFlexibility = $theConcept/@effectiveDate] | //terminologyAssociation[@conceptId = $theConcept/@id][not(@conceptFlexibility)][$theConceptIsNewest]"/>
                        <sch:let name="tempElement" value="$theElement[matches(@name,'^[^:]+:value')][matches(parent::element/lower-case(@name),'^[^:]+:\S*observation')]/preceding-sibling::element[matches(@name,'^[^:]+:code')]"/>
                        <sch:assert role="warning" test="$theTemplate[@statusCode=('cancelled','rejected','retired')] or not($theConcept) or not($theElement) or not($termAssocsConcept) or not($tempElement) or $termAssocsConcept[concat(@code,'#',@codeSystem)=$tempElement/vocabulary/concat(@code,'#',@codeSystem)]"
                            >WARNING: Element '<sch:value-of select="$theElement/@name"/>' (id=<sch:value-of select="$elid"/>) is not bound to the same code as the dataset concept<sch:value-of select="concat(' ''',$theConcept/name[string-length()>0][1],'''')"/>. 
                            Found "code='<sch:value-of select="$tempElement/vocabulary/@code"/>' codeSystem='<sch:value-of select="$tempElement/vocabulary/@codeSystem"/>'", expected "code / codeSystem='<sch:value-of select="distinct-values($termAssocsConcept/concat(@code,' / ',@codeSystem))"/>'".<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <!--<sch:let name="conceptIsItem" value="if ($datasetConcept) then exists(//datasets//concept[@id=$conceptId][not(@effectiveDate) or @effectiveDate=$conceptEffectiveDate][not(ancestor::history)][@type='item' or not(concept)][not(valueDomain/@type='complex')]) else (false())"/>-->
                        <!--<sch:let name="elementHasDatatype" value="if ($templateElement) then ancestor::rules/template[@id=$templateId][@effectiveDate=$templateEffectiveDate]//*[@id=$elementId][@datatype] else()"/>-->
                        <!--<sch:assert role="warning" test="not($templateElement) or not($conceptIsItem) or $elementHasDatatype"
                            >WARNING: Concept item <sch:value-of select="$conceptId"/> (<sch:value-of select="$conceptEffectiveDate"/>) SHOULD probably be bound to an element with a datatype.<sch:value-of select="$locationContext"/></sch:assert>-->
                        <sch:assert role="error" test="@elementId and not(@elementPath)"
                            >ERROR: A template association SHALL have exclusively @elementId.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                    <sch:rule context="structuredefinition/concept">
                        <sch:let name="locationContext" value="concat(' | Location &lt;structuredefinition ', string-join(for $att in ancestor::structuredefinition/(@displayName, @id, @version, @url) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:assert role="error" test="(@elementId | @elementPath) and not(@elementId and @elementPath)"
                            >ERROR: A structuredefinition association SHALL have exclusively either @elementId or @elementPath, not both.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:attribute name="ref" type="Oid" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a concept/@id that is not in history or in a concept list</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required"/>
        <!-- either elementId if elements have ids, path expressions like Observation.code or Act/@classCode otherwise -->
        <xs:attribute name="elementId" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">For Templates this matches an element of attribute @id attribute. For StructureDefinitions this matches an element @id attribute</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="elementPath" type="xs:anyURI" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">For Templates this attribute is not applicable. For StructureDefinitions this matches an element/path/@value attribute. The attribute @elementPath is only relevant in the absence of an element/@id to bind on. When StructureDefinitions contains slicing then the element/path/@value will NOT be unique making the making the binding ambiguous.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="TemplateDefinition">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Rules/Templates</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]">
                        <sch:let name="locationContext" value="concat(' | Location &lt;template ', string-join(for $att in ancestor-or-self::template[1]/(@id, @ref, @name, @displayName, @effectiveDate) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        <sch:let name="tmid" value="@id"/>
                        
                        <sch:assert role="error" test="(@id and @effectiveDate) or @ref"
                            >ERROR: <sch:name/> SHALL have an @id and @effectiveDate, or a @ref.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@id and @ref)"
                            >ERROR: <sch:name/> SHALL NOT have both @id and @ref.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@canonicalUri and @ref)"
                            >ERROR: <sch:name/> SHALL NOT have both @canonicalUri and @ref.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:assert role="error" test="not(context[@id='*']) or element[@minimumMultiplicity > 0][matches(@name,'^([^:]+:)?templateId(\[.*)?$')]/attribute[not(@isOptional = 'true')][not(@prohibited = 'true')][@root=$tmid or (@name='root' and @value=$tmid)]"
                            >ERROR: If context of template is *, it SHALL have a top level, element with minimum cardinality > 0, named templateId (e.g. hl7:templateId) with a required attribute @root id (or name value pair) of that template.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(context[@id='**']) or */element[@minimumMultiplicity > 0][matches(@name,'^([^:]+:)?templateId(\[.*)?$')]/attribute[not(@isOptional = 'true')][not(@prohibited = 'true')][@root=$tmid or (@name='root' and @value=$tmid)]"
                            >ERROR: If context of template is **, it SHALL have, immediately under the top level element, an element with minimum cardinality > 0, named templateId (e.g. hl7:templateId) with a required attribute @root id (or name value pair) of that template.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(context[@path = ('*','**')])"
                            >ERROR: Template context path SHALL be '/','//', or an xpath expression. Found '<sch:value-of select="context/@path"/>'.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(context[@path = ('**')]) or .[element][count(attribute | element | include | choice) = 1]"
                            >ERROR: If template context id = '**' then template SHALL have exactly 1 element and SHALL NOT have other top level attributes/includes/choices. Found '<sch:value-of select="count(attribute | element | include | choice)"/>'.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:assert role="error" test="not(@id and (@*[name()=('ref','flexibility')]))"
                            >ERROR: A template with a @id SHALL NOT have attributes @ref or @flexibility.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@ref and (@*[not(name()=('ref','name','displayName','url','ident'))][empty(namespace-uri())] or *[not(name()='desc')]))"
                            >ERROR: A template with a @ref SHALL NOT have other attributes than @name or @displayName and MAY have a description.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:assert role="error" test="@ref or (@effectiveDate and @statusCode)"
                            >ERROR: A template SHALL have @ref or (@effectiveDate and @statusCode).<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:assert role="warning" test="not(ends-with(element[1]/@name, 'ClinicalDocument')) or context"
                            >ERROR: A CDA Document Level Template with a ClinicalDocument element as root SHALL have a context, e.g. &lt;context path=&apos;/&apos;/>.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:let name="allElementIds" value=".//element/@id | .//attribute/@id"/>
                        <sch:let name="duplicateIds" value="for $elementId in $allElementIds return if (count($allElementIds[. = $elementId]) > 1) then $elementId else ()"/>
                        
                        <sch:assert role="error" test="empty($duplicateIds)"
                            >ERROR: Template element and attribute ids SHALL be unique with the same template id/version. Found duplicates: '<sch:value-of select="distinct-values($duplicateIds)"/>'.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:let name="format" value="if (classification/@format) then (classification/@format)[1] else ('hl7v3xml1')"/>
                        <sch:let name="artdecor" value="'http://art-decor.org/ADAR/rv/'"/>
                        <sch:let name="datatypeFile" value="if ($format = 'hl7v3xml1') then ('DECOR-supported-datatypes.xml') else concat('DECOR-supported-datatypes-',$format,'.xml')"/>
                        <!-- Extra $artdecor is necessary for supported in check-decor.xquery that will not resolve the file next to us (...sigh) -->
                        <sch:let name="supportedDatatypes" value="if (doc-available($datatypeFile)) then doc($datatypeFile) else if (doc-available(concat($artdecor,$datatypeFile))) then doc(concat($artdecor,$datatypeFile)) else ()"/>
                        <sch:assert role="error" test="$supportedDatatypes"
                            >ERROR: Template does not have a supported classification/@format "<sch:value-of select="$format"/>" or <sch:value-of select="$datatypeFile"/> is missing.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:let name="isBBR" value="ancestor::*/@repository='true'"/>
                        <sch:let name="isfromBBR" value="@url and @ident"/>
                        <sch:report role="error" test="$isBBR and not($isfromBBR) and (.//element[not(@id)] | .//attribute[not(@id)])"
                            >ERROR: Template is part of a building block repository and is missing one or more @id attributes on &lt;element/&gt; and/or &lt;attribute/&gt;. This may lead to problems on templates that use this template as prototype.<sch:value-of select="$locationContext"/></sch:report>
                        <sch:report role="warning" test="$isfromBBR and (.//element[not(@id)] | .//attribute[not(@id)])"
                            >ERROR: Template is part of a foreign building block repository and is missing one or more @id attributes on &lt;element/&gt; and/or &lt;attribute/&gt;. This may lead to problems on templates that use this template as prototype. Please request the BBR maintaining parties to update their templates (@url="<sch:value-of select="@url"/>" and @prefix="<sch:value-of select="@ident"/>").<sch:value-of select="$locationContext"/></sch:report>
                    </sch:rule>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired','active'))]//*[name()=('attribute','element','include','constraint','let','defineVariable','assert','report')]">
                        <sch:let name="locationContext" value="concat(' | Location &lt;template ', string-join(for $att in ancestor-or-self::template[1]/(@id, @ref, @name, @displayName, @effectiveDate) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        <sch:let name="name" value="name()"/>
                        <sch:let name="duplicates" value="string-join(for $att in @* return $att,'')=following-sibling::*[name()=$name]/string-join(for $att in @* return $att,'')"/>
                        <sch:assert role="warning" test="not($duplicates)"
                            >WARNING: <sch:name/> has sibling <sch:name/> particles that carry the same values for the attribute @name,@ref,@contains,@test,@id,@language. This could lead to merge problems in editing templates based on this templates. Consider adding predicates or updating the test clause to make these particles distinct.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <!-- description(s) of template -->
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
             <!-- the type(s) etc of the template, for later use -->
            <xs:element name="classification" type="TemplateProperties" minOccurs="0" maxOccurs="unbounded"/>
            <!-- relationships of this template -->
            <xs:element name="relationship" type="TemplateRelationships" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:appinfo>
                        <sch:pattern>
                        <sch:title>Validate Template Relationship</sch:title>
                            <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]/relationship">
                                <sch:let name="locationContext" value="concat(' | Location &lt;template ', string-join(for $att in ancestor-or-self::template[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                                
                                <sch:assert role="error" test="(@template or @model) and not(@template and @model)"
                                    >ERROR: A template relationship SHALL have either <sch:name/>/@template or <sch:name/>/@model, and not both.<sch:value-of select="$locationContext"/></sch:assert>
                                <sch:assert role="error" test="not(@model) or @type='DRIV'"
                                    >ERROR: A template relationship to a model SHALL be 'DRIV' (derived).<sch:value-of select="$locationContext"/></sch:assert>
                                <sch:assert role="warning" test="not(@template) or matches(@template,'^[0-9\.]+$')"
                                    >WARNING: A template relationship/@template='<sch:value-of select="@template"/>' references SHOULD be based on template/@id. References by @name quickly become ambiguous.<sch:value-of select="$locationContext"/></sch:assert>
                            </sch:rule>
                        </sch:pattern>
                    </xs:appinfo>
                </xs:annotation>
            </xs:element>
            <!-- context of template
                either
                <context id="*"/> for an element templateId context
                or <context path="//"/> for a specific context path
            -->
            <!-- 
                there may be one publishing and one or more endorsing authorities
                not used by DECOR yet
            -->
            <xs:element name="publishingAuthority" type="AuthorityType" minOccurs="0" maxOccurs="0">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The authoritative body who has reviewed the Template for (clinical) accuracy and relevance, 
                        and authorized it for publication. Registries may require this element to be valued</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="endorsingAuthority" type="AuthorityType" minOccurs="0" maxOccurs="0">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A list of bodies who have reviewed the Template for (clinical) accuracy and relevance, 
                        and endorsed it for use</xs:documentation>
                </xs:annotation>
            </xs:element>
            <!-- FHIR compatibility -->
            <xs:element name="purpose" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A statement about the purpose of the template</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="copyright" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A copyright statement relating to the template and/or its contents.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <!-- 
                there may be 0..* template revision history discriptions
                not used by DECOR yet
            -->
            <xs:element name="revisionHistory" type="ObjectHistory" minOccurs="0" maxOccurs="0">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The free text description describing the changes in this version of the Template as compared to the previous version. 
                        Since Template versions are built off of previous versions, the net effect of this field is to function as a
                        comprehensive historical reference of the Template.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element ref="context" minOccurs="0" maxOccurs="1"/>
            <!-- item reference and description(s), inherited by all subsequent elements unless overridden -->
            <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
            
            <!-- examples may be given -->
            <xs:element ref="example" minOccurs="0" maxOccurs="unbounded"/>
            <!-- 
                there maybe 0..n inherit definitions before others in a template (indicating parent / sibling templates)
                not used by DECOR yet
            -->
            <xs:element name="inherit" type="InheritDefinition" minOccurs="0" maxOccurs="0"/>
            <!-- 
                the design body: elements, attributes, choices or includes
            -->
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="attribute" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="choice" type="ChoiceDefinition" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="element" type="RuleDefinition" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="include" type="IncludeDefinition" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element ref="let" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="assert" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="report" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="defineVariable" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:choice>
        </xs:sequence>

        <!-- attributes of element (validation done by embedded schematron) -->
        <xs:attribute name="id" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The identifying OID of the template</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute ref="canonicalUri" use="optional"/>
        <xs:attribute name="ref" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a template/@id. Templates SHALL carry either @id or @ref</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="ShortFormalName" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The mnemonic name of the template</xs:documentation>
            </xs:annotation>
        </xs:attribute>

        <!-- attributes of template (validation done by embedded schematron) -->
        <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
        <xs:attribute name="statusCode" type="TemplateStatusCodeLifeCycle" use="optional"/>
        <xs:attribute ref="displayName" use="optional"/>
        <xs:attribute name="isClosed" type="xs:boolean" use="optional" default="false">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Whether the template is open (other elements than specified allowed) or closed (no other elements than specified allowed)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        
        <!-- Only relevant after compilation -->
        <xs:attributeGroup ref="TemplateCompilationAttributes"/>
    </xs:complexType>
    <xs:complexType name="AuthorityType" mixed="true">
        <xs:sequence>
            <xs:element ref="addrLine" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Id of the authority/organisation/person</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="NonEmptyString" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Name of the authority/organisation/person</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <!--<xs:attribute name="email" type="EmailType" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Email address of the authority/organisation/person</xs:documentation>
            </xs:annotation>
        </xs:attribute>-->
    </xs:complexType>
    <xs:complexType name="ObjectHistory">
        <xs:sequence>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="date" type="TimeStampNoTimezone"/>
        <xs:attribute name="by" type="NonEmptyString"/>
    </xs:complexType>
    <xs:complexType name="TemplateProperties">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The classification of the template</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="tag" type="NonEmptyString" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">In addition, tag elements could be incorporated to specifiy any number of tags for search purposes</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="property" type="NonEmptyString" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">In addition, property elements could be incorporated to specifiy any number of properties not part of the standard metadata, e.g. for operationalization instructions</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="type" type="TemplateTypes" use="required"/>
        <xs:attribute name="format" type="TemplateFormats" use="optional" default="hl7v3xml1"/>
    </xs:complexType>
    <xs:simpleType name="TemplateTypes">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The type of the template, something like "cdaentrylevel", "cdasectionlevel", "messagelevel" etc.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="cdadocumentlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">CDA document level template</xforms:label>
                        <xforms:label xml:lang="en-US">CDA Document Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">CDA Document Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">CDA Document Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="messagelevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v2/v3 message level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V2/V3 Message Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V2/V3 Message Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V2 or V3 Message Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cdaheaderlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">CDA header level template</xforms:label>
                        <xforms:label xml:lang="en-US">CDA Header Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">CDA Header Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">CDA Header Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cdasectionlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">CDA section level template</xforms:label>
                        <xforms:label xml:lang="en-US">CDA Section Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">CDA Section level template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">CDA Section Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cdaentrylevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">CDA entry level template</xforms:label>
                        <xforms:label xml:lang="en-US">CDA Entry Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">CDA Entry Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">CDA Entry Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="segmentlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v2 segment level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V2 Segment Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V2 Segment Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V2 Segment Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="clinicalstatementlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v3 Clinical Statement level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V3 Clinical Statement Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V3 Clinical Statement Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V3 Clinical Statement Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="controlactlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v3 Control Act level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V3 Control Act Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V3 Control Act Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V3 Control Act Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="payloadlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v3 Payload level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V3 Payload Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V3 Payload Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V3 Payload Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="datatypelevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v2/v3 datatype level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V2/V3 Datatype Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V2/V3 Datatype Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V2 or V3 Datatype Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="notype">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Templatetype niet gespecificeerd</xforms:label>
                        <xforms:label xml:lang="en-US">Template type not specified</xforms:label>
                        <xforms:label xml:lang="de-DE">Template-Typ nicht spezifiziert</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template type not specified</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="TemplateRelationships">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The relationships of the template regarding other templates or model artifacts</xs:documentation>
        </xs:annotation>
        <xs:attribute name="type" type="RelationshipTypes" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The @type of the relationship of the template, at this point in time something like "SPEC", "GEN", "EQUIV", "VERSION", etc.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="template" type="BasicIdOrOid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">A reference by name or id to a template identifier, used for template-template relationships</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="model" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">A reference to a model artifact identifier or description specifying from what this template is derived from or based on, e.g. an HL7 R-MIM, a DCM,
                    used for template-model relationships</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a template/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="RelationshipTypes">
        <xs:restriction base="xs:NMTOKEN">
            <!-- Template-template relationships -->
            <xs:enumeration value="REPL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Vervanging</xforms:label>
                        <xforms:label xml:lang="en-US">Replacement</xforms:label>
                        <xforms:label xml:lang="de-DE">Ersatz</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template replaces @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SPEC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Specialisatie</xforms:label>
                        <xforms:label xml:lang="en-US">Specialization</xforms:label>
                        <xforms:label xml:lang="de-DE">Spezialisierung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template specializes @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="GEN">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Generalisatie</xforms:label>
                        <xforms:label xml:lang="en-US">Generalization</xforms:label>
                        <xforms:label xml:lang="de-DE">Generalisierung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template generalizes @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="COPY">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Kopie</xforms:label>
                        <xforms:label xml:lang="en-US">Copy</xforms:label>
                        <xforms:label xml:lang="de-DE">Kopie</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is a design copy of @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ADAPT">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Adaptatie</xforms:label>
                        <xforms:label xml:lang="en-US">Adaptation</xforms:label>
                        <xforms:label xml:lang="de-DE">Adaptation</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is an adaptation of @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="EQUIV">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Equivalent</xforms:label>
                        <xforms:label xml:lang="en-US">Equivalent</xforms:label>
                        <xforms:label xml:lang="de-DE">Equivalent</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is equivalent to @template regarding design</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="VERSION">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Versie</xforms:label>
                        <xforms:label xml:lang="en-US">Version</xforms:label>
                        <xforms:label xml:lang="de-DE">Version</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is a version of @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="BACKWD">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Backward compatible</xforms:label>
                        <xforms:label xml:lang="en-US">Backward Compatible</xforms:label>
                        <xforms:label xml:lang="de-DE">Rückwärtskompatibel</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is backward compatible of @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- Template-model relationships -->
            <xs:enumeration value="DRIV">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Afgeleide</xforms:label>
                        <xforms:label xml:lang="en-US">Derived</xforms:label>
                        <xforms:label xml:lang="de-DE">Abgeleitet</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">For future use: This template is derived from model or other artifact expressed or specified in the @template attribute</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="TemplateFormats">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">As of now only a few formats are supported, e.g. "HL7 V3 XML ITS 1" = hl7v3xml1</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="hl7v3xml1">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format HL7v3 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="en-US">Template format HL7 V3 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format HL7 V3 XML ITS 1</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format HL7 V3 XML ITS 1</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!--<xs:enumeration value="hl7v2.3.1xml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format HL7v2.3.1 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="en-US">Template format HL7 V2.3.1 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format HL7 V2.3.1 XML ITS 1</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format HL7 V2.3.1 XML ITS 1</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="hl7v2.4xml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format HL7v2.4 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="en-US">Template format HL7 V2.4 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format HL7 V2.4 XML ITS 1</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format HL7 V2.4 XML ITS 1</xs:documentation>
                </xs:annotation>
            </xs:enumeration>-->
            <xs:enumeration value="hl7v2.5xml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format HL7v2.5 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="en-US">Template format HL7 V2.5 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format HL7 V2.5 XML ITS 1</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format HL7 V2.5 XML ITS 1</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="fhirxml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format FHIR XML</xforms:label>
                        <xforms:label xml:lang="en-US">Template format FHIR XML</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format FHIR XML</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format FHIR XML</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="vmrxml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format vMR CDS XML</xforms:label>
                        <xforms:label xml:lang="en-US">Template format vMR CDS XML</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format vMR CDS XML</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format vMR CDS XML</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="RuleDefinition">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Rules/Templates</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//element">
                        <sch:let name="locationContext" value="concat(' | Location &lt;template ', string-join(for $att in ancestor-or-self::template[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:assert role="error" test="not(@isMandatory='true' and @minimumMultiplicity=0)"
                            >ERROR: If template element isMandatory=true, minimumMultiplicity SHALL be greater than 0.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@conformance='NP' and (@minimumMultiplicity>0 or @isMandatory='true'))"
                            >ERROR: If template element conformance=NP, minimumMultiplicity SHALL be 0 and isMandatory SHALL be false.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:assert role="error" test="not(@isMandatory='true' and attribute[(@nullFlavor or @name='nullFlavor')][not(@prohibited='true')])"
                            >ERROR: Template element defines a @nullFlavor, but element has @isMandatory='true'.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:assert role="error" test="not(references)"
                            >ERROR: The &lt;references/&gt; element SHALL NOT be used any more. Use rules/templateAssociation instead.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:let name="projectId" value="(//project/@id)[1]"/>
                        <sch:let name="tmid" value="@contains"/>
                        <sch:let name="flextext" value="if (@flexibility) then (@flexibility) else ('dynamic')"/>
                        <sch:let name="matches" value="//rules/template[(@id|@name)=$tmid]/xs:dateTime(@effectiveDate)"/>
                        <sch:let name="tmed" value="if (matches(@flexibility,'^\d{4}')) then (@flexibility) else (max($matches))"/>
                        <sch:let name="reffedTemplate" value="//rules/template[(@id|@name)=$tmid][@effectiveDate=$tmed] | //rules/template[@ref=$tmid]"/>
                        <sch:assert role="error" test="if ($tmid and (starts-with($tmid, concat($projectId,'.')) or ancestor::decor[@versionDate])) then ($reffedTemplate) else (true())"
                            >ERROR: Template element/@contains='<sch:value-of select="$tmid"/>' SHALL point to an existing template with flexibility '<sch:value-of select="$flextext"/>'.<sch:value-of select="if (ancestor::decor[@versionDate]) then (' In a compiled project, all references are expected to be resolved.') else (' The artifact would appear to be part of your project based on id. It might be resolved during pre-publication compile phase, regardless of a reference, but they will not be in your list of artifacts in ART while there is no reference.')"/><sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="info" test="if ($tmid and not(starts-with($tmid, concat($projectId,'.')) or ancestor::decor[@versionDate])) then ($reffedTemplate) else (true())"
                            >WARNING: Template element/@contains='<sch:value-of select="$tmid"/>' SHOULD point to an existing template with flexibility '<sch:value-of select="$flextext"/>'. Note that in the pre-publication compile phase these references will be resolved if possible, regardless of a reference, but they will not be in your list of artifacts in ART while there is no reference.<sch:value-of select="$locationContext"/></sch:assert>
                        <!--<sch:assert role="warning" test="not(@contains and //rules/template[@id=$ref or @name=$ref][@effectiveDate=$flexibility][not(context)])"
                            >WARNING: <sch:name/>/@contains='<sch:value-of select="$ref"/>' flexibility '<sch:value-of select="$flextext"/>' points to a template without context. Best practise is usually to use include instead of element/@contains.<sch:value-of select="$locationContext"/></sch:assert>-->
                        <sch:assert role="info" test="not(@contains and $reffedTemplate[context/@path[not(.='//')]]) or parent::choice"
                            >INFO: Template element/@contains='<sch:value-of select="$tmid"/>' flexibility '<sch:value-of select="$flextext"/>' points to a template with context/@path='<sch:value-of select="$reffedTemplate/context/@path"/>'. Best practise is to call this type of template only from a transaction. When called from another template, this context path is overridden by the context of the calling template.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="warning" test="not(@contains) or matches(@contains,'^[0-9\.]+$')"
                            >WARNING: Template element/@contains='<sch:value-of select="@contains"/>' references SHOULD be based on template/@id. References by @name quickly become ambiguous.<sch:value-of select="$locationContext"/></sch:assert>
                        <!--
                        <sch:assert test="not (@minimumMultiplicity and @isMandatory) or (@isMandatory='true' and @minimumMultiplicity>0)"
                        >ERROR: if isMandatory=true, minimumMultiplicity shall be greater than 0.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert test="not(@name and @include) and not(@name and @contains)"
                        >An element may contain @name or @name/@contains or @include.<sch:value-of select="$locationContext"/></sch:assert>
                        -->
                        
                        <!-- Background: the check on valueSet does not consider code(System)s in the other vocabulary element and vice versa. So there will be errors about a valid codeSystem or a valid code regardless -->
                        <!--<sch:assert role="warning" test="not(vocabulary[@valueSet] and vocabulary[@code or @codeSystem])"
                            >WARNING: combining vocabulary definitions based on a valueSet and based on a @code and/or @codeSystem is currently not supported in the schematron engine. Consider creating a valueSet that supports the specified combination.<sch:value-of select="$locationContext"/></sch:assert>-->
                        
                        <sch:let name="format" value="if (ancestor::template/classification/@format) then (ancestor::template/classification/@format)[1] else ('hl7v3xml1')"/>
                        <sch:let name="artdecor" value="'http://art-decor.org/ADAR/rv/'"/>
                        <sch:let name="datatypeFile" value="if ($format = 'hl7v3xml1') then ('DECOR-supported-datatypes.xml') else concat('DECOR-supported-datatypes-',$format,'.xml')"/>
                        
                        <!-- Extra $artdecor is necessary for supported in check-decor.xquery that will not resolve the file next to us (...sigh) -->
                        <sch:let name="supportedDatatypes" value="if (doc-available($datatypeFile)) then doc($datatypeFile) else if (doc-available(concat($artdecor,$datatypeFile))) then doc(concat($artdecor,$datatypeFile)) else ()"/>
                        
                        <!--<sch:let name="dtNsURI" value="if (contains(@datatype,':')) then namespace-uri-for-prefix(substring-before(@datatype,':')) else ('urn:hl7-org:v3')"/>-->
                        <sch:let name="dt" value="@datatype"/>
                        <sch:let name="dtName" value="if (contains($dt,':')) then substring-after($dt,':') else ($dt)"/>
                        <sch:assert role="error" test="not($supportedDatatypes) or not(@datatype) or $supportedDatatypes//(dataType|flavor)[@name=($dt,$dtName)]"
                            >ERROR: Template element/@datatype '<sch:value-of select="@datatype"/>' SHALL be a supported datatype (reference file: <sch:value-of select="$datatypeFile"/>).<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:let name="elmpfx" value="substring-before(@name,':')"/>
                        <sch:let name="elmns" value="if ($elmpfx=('hl7','cda')) then ('urn:hl7-org:v3') else if (string-length($elmpfx) gt 0) then (namespace-uri-for-prefix($elmpfx, .)) else ()"/>
                        <!-- Filthy hack because eXist-db 2.2 will not yield data on in-memory nodes with namespace-uri-for-prefix(). The namespace declaration might exist nonetheless, e.g. as @sdtc:dummy-1, on the template node (compiled project), or the decor root node -->
                        <sch:assert role="error" test="not(@name) or not(empty($elmns)) or ancestor::template/@*[starts-with(name(), concat($elmpfx,':'))] or ancestor::decor/@*[starts-with(name(), concat($elmpfx,':'))]"
                            >ERROR: Template element/@name='<sch:value-of select="@name"/>' SHALL have a known namespace prefix '<sch:value-of select="$elmpfx"/>' ('hl7' and 'cda' are declared by default, any other SHALL be declared on the root element decor).<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <!--<sch:assert role="error" test="not(@id) or count(index-of(ancestor::template//@id,@id))=1"
                            >ERROR: Template element/@id='<sch:value-of select="@id"/>' SHALL be unique within the template (version). Found <sch:value-of select="count(index-of(ancestor::template//@id,@id))"/> occurrences.<sch:value-of select="$locationContext"/></sch:assert>-->
                        
                        <sch:let name="elmname" value="substring-after(if (contains(@name,'[')) then substring-before(@name,'[') else (@name),concat($elmpfx,':'))"/>
                        <!--http://stackoverflow.com/questions/1631396/what-is-an-xsncname-type-and-when-should-it-be-used-->
                        <sch:assert role="error" test="not(@name) or matches(@name, '^[^:\s]+:[^\d][A-Za-z\d\._-]*')"
                            >ERROR: Template element/@name='<sch:value-of select="@name"/>' SHALL be a QName with (<sch:value-of select="$elmname"/>) or without predicate between brackets.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <!-- description(s) of elements -->
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            <!-- item label, inherited by all subsequent elements unless overridden -->
            <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
            <!-- examples may be given -->
            <xs:element ref="example" minOccurs="0" maxOccurs="unbounded"/>
            <!-- 
                there maybe 0..1 inherit definitions before others in an element (indicating parent and sibling templates)
            -->
            <xs:element name="inherit" type="InheritDefinition" minOccurs="0" maxOccurs="0"/>
            <!-- 
                there may be 0..* vocabulary and 0..* property specifications
            -->
            <xs:choice>
                <xs:element ref="vocabulary" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="property" minOccurs="0" maxOccurs="unbounded"/>
            </xs:choice>
            <!-- 
                there may be 0..* text (element content) specifications
            -->
            <xs:element name="text" type="NonEmptyString" minOccurs="0" maxOccurs="unbounded"/>

            <!-- 
                attribute(s)
            -->
            <xs:element ref="attribute" minOccurs="0" maxOccurs="unbounded"/>
            <!-- 
                choice of
                
                let
                assert 
                report
                
                defineVariable
                
                include
                
                choice
                
                or a new nested element
                
                or (non rule generating) items
                constraint
                issue
            -->
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="let" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="assert" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="report" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="defineVariable" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="element" type="RuleDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="include" type="IncludeDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="choice" type="ChoiceDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <!-- DEPRECATED: <xs:element ref="references" minOccurs="0" maxOccurs="unbounded"/> -->
                <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:choice>
        </xs:sequence>

        <!-- attributes of template (validation done by embedded schematron) -->
        <xs:attribute ref="displayName" use="optional"/>
        <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
        <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="optional"/>

        <!-- attributes of element (validation done by embedded schematron) -->
        <xs:attribute name="name" use="optional" type="xs:anyURI"/>

        <!-- @include is no longer supported and replaced by the include element, useWhere is not implemented yet -->
        <xs:attribute name="include" type="xs:anyURI" use="prohibited"/>
        <xs:attribute name="useWhere" type="xs:boolean" default="false" use="optional"/>

        <!-- @contains -->
        <xs:attribute name="contains" type="BasicIdOrOid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a template/@id or @name. References to @name are discouraged because they become ambiguous quickly.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a template/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
        <xs:attribute name="conformance" type="ConformanceType" use="optional"/>
        <xs:attribute name="isMandatory" type="xs:boolean" default="false" use="optional"/>

        <!-- an optional id for to be referenced by associated concepts -->
        <xs:attribute name="id" type="Oid"/>

        <!-- data type -->
        <!--<xs:attribute name="datatype" type="DatatypeName"/>-->
        <xs:attribute name="datatype" type="xs:QName"/>
        <xs:attribute name="isClosed" type="xs:boolean" use="optional" default="false">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Whether the template is open (other elements than specified allowed) or closed (no other elements than specified allowed)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        
        <!-- coding strength -->
        <xs:attribute name="strength" type="CodingStrengthType" default="required" use="optional"/>
        
    </xs:complexType>
    <xs:complexType name="IncludeDefinition">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate includes</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//include">
                        <sch:let name="locationContext" value="concat(' | Location &lt;template ', string-join(for $att in ancestor-or-self::template[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:assert role="error" test="not(@isMandatory='true' and @minimumMultiplicity=0)"
                            >ERROR: If template include isMandatory=true, minimumMultiplicity SHALL be greater than 0.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@conformance='NP' and (@minimumMultiplicity>0 or @isMandatory='true'))"
                            >ERROR: If template include conformance=NP, minimumMultiplicity SHALL be 0 and isMandatory SHALL be false.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:let name="projectId" value="(//project/@id)[1]"/>
                        <sch:let name="tmid" value="@ref"/>
                        <sch:let name="flextext" value="if (@flexibility) then (@flexibility) else ('dynamic')"/>
                        <sch:let name="matches" value="//rules/template[(@id|@name)=$tmid]/xs:dateTime(@effectiveDate)"/>
                        <sch:let name="tmed" value="if (matches(@flexibility,'^\d{4}')) then (@flexibility) else (max($matches))"/>
                        <sch:let name="reffedTemplate" value="//rules/template[(@id|@name)=$tmid][@effectiveDate=$tmed] | //rules/template[@ref=$tmid]"/>
                        <sch:assert role="error" test="if ($tmid and (starts-with($tmid, concat($projectId,'.')) or ancestor::decor[@versionDate])) then ($reffedTemplate) else (true())"
                            >ERROR: Template include/@ref='<sch:value-of select="$tmid"/>' SHALL point to an existing template with flexibility '<sch:value-of select="$flextext"/>' or a template/@ref.<sch:value-of select="if (ancestor::decor[@versionDate]) then (' In a compiled project, all references are expected to be resolved.') else (' The artifact would appear to be part of your project based on id. It might be resolved during pre-publication compile phase, regardless of a reference, but they will not be in your list of artifacts in ART while there is no reference.')"/><sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="info" test="if ($tmid and not(starts-with($tmid, concat($projectId,'.')) or ancestor::decor[@versionDate])) then ($reffedTemplate) else (true())"
                            >WARNING: Template include/@ref='<sch:value-of select="$tmid"/>' SHOULD point to an existing template with flexibility '<sch:value-of select="$flextext"/>' or a template/@ref. Note that in the pre-publication compile phase these references will be resolved if possible, regardless of a reference, but they will not be in your list of artifacts in ART while there is no reference.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not($reffedTemplate/attribute) or parent::template or (parent::element and not(preceding-sibling::element|preceding-sibling::choice))"
                            >ERROR: Template include/@ref='<sch:value-of select="$tmid"/>' points to a template with top level attributes, but your context is not an element.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="info" test="count(parent::element/choice|parent::element/include|parent::element/element)!=1 or not(@ref and $reffedTemplate[context/@id])"
                            >INFO: Template include/@ref='<sch:value-of select="$tmid"/>' flexibility '<sch:value-of select="$flextext"/>' points to a template with context/@id. Best practise when this include is the only content is to use element/@contains instead of include.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="info" test="not(@ref and $reffedTemplate[context/@path[not(.='//')]])"
                            >INFO: Template include/@ref='<sch:value-of select="$tmid"/>' flexibility '<sch:value-of select="$flextext"/>' points to a template with context/@path='<sch:value-of select="$reffedTemplate/context/@path"/>'. Best practise is to call this type of template only from a transaction. When called from another template, this context path is overridden by the context of the calling template.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:let name="tcnt" value="count($reffedTemplate/(element|choice|include))"/>
                        <sch:assert role="warning" test="not(@minimumMultiplicity|@maximumMultiplicity|@conformance[not(. = 'R')]|@isMandatory) or $tcnt &lt;= 1"
                            >WARNING: The template you reference has multiple elements. If you specify multiplicity, conformance or isMandatory it applies to all of them.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not((@conformance[not(. = 'NP')]|@isMandatory[.='true']) and $reffedTemplate/*[@conformance = 'NP'])"
                            >ERROR: A template include SHALL NOT override @conformance='NP' in the template it refers to.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not((@conformance[.=('C','NP')]|@isMandatory[.='false']) and $reffedTemplate/*[@isMandatory = 'true'])"
                            >ERROR: A template include SHALL NOT override @isMandatory='true' in the template it refers to.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="warning" test="not(@ref) or matches(@ref,'^[0-9\.]+$')"
                            >WARNING: Template include/@ref='<sch:value-of select="@ref"/>' references SHOULD be based on template/@id. References by @name quickly become ambiguous.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <!-- description(s) of an include -->
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            <!-- item label, inherited by all subsequent elements unless overridden -->
            <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
            <xs:element ref="example" minOccurs="0" maxOccurs="unbounded"/>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <!-- DEPRECATED: <xs:element ref="references" minOccurs="0" maxOccurs="unbounded"/> -->
                <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:choice>
        </xs:sequence>

        <!-- attributes of includes (validation done by embedded schematron) -->
        <xs:attribute name="ref" type="BasicIdOrOid" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a template/@id or @name. References to @name are discouraged because they become ambiguous quickly.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a template/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>

        <!-- attributes of includes (validation done by embedded schematron) -->
        <xs:attribute name="scenario" type="NonEmptyString" use="prohibited"/>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="prohibited"/>
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
        <xs:attribute name="conformance" type="ConformanceType" use="optional"/>
        <xs:attribute name="isMandatory" type="xs:boolean" default="false" use="optional"/>
    </xs:complexType>
    <xs:complexType name="InheritDefinition">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Inherit an artefact (here: a concept or a template), referenced by a ref (id). 
                If no effectiveDate is given, flexibility DYNAMIC is assumed, STATIC date otherwise.</xs:documentation>
        </xs:annotation>
        <!-- attributes of inherit (validation done by embedded schematron) -->
        <xs:attribute name="ref" type="Oid" use="required"/>
        <!-- attributes of inherit (validation done by embedded schematron) -->
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required"/>
        
        <!-- Only relevant after compilation -->
        <xs:attributeGroup ref="InheritCompilationAttributes"/>
    </xs:complexType>
    <xs:complexType name="ContainsDefinition">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Contains an artefact (here: a concept or a template), referenced by a ref (id). 
                If no flexibility is given, flexibility DYNAMIC is assumed, STATIC date otherwise.</xs:documentation>
        </xs:annotation>
        <!-- attributes of contains (validation done by embedded schematron) -->
        <xs:attribute name="ref" type="Oid" use="required"/>
        <!-- attributes of contains (validation done by embedded schematron) -->
        <xs:attribute name="flexibility" type="StaticFlexibility" use="required"/>
        
        <!-- Only relevant after compilation -->
        <xs:attributeGroup ref="InheritCompilationAttributes"/>
    </xs:complexType>
    <xs:complexType name="ChoiceDefinition">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Choice of elements and includes. The choice supports min/max occurence and any of its constituents may have a min/max occurence. Min/max on consituents cannot exceed the min/max boundaries of the choice.</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate choices</sch:title>
                    <!--<sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//choice">
                        <sch:let name="choicemin" value="@minimumMultiplicity[string-length()>0]"/>
                        <sch:let name="totalmin" value="sum((element|include|choice)[@minimumMultiplicity castable as xs:integer]/xs:integer(@minimumMultiplicity))"/>
                        
                        <sch:assert role="error" test="if ($choicemin castable as xs:integer and $totalmin) then (xs:integer($choicemin) ge $totalmin) else true()"
                            >ERROR: <sch:name/>/@minimumMultiplicity '<sch:value-of select="$choicemin"/>' SHALL be greater or equal to the sum of the @minimumMultiplicities '<sch:value-of select="$totalmin"/>' of the constituents.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>-->
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//choice/element | 
                                       template[not(@statusCode=('cancelled','rejected','retired'))]//choice/include | 
                                       template[not(@statusCode=('cancelled','rejected','retired'))]//choice">
                        <sch:let name="locationContext" value="concat(' | Location &lt;template ', string-join(for $att in ancestor-or-self::template[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:let name="choicemin" value="if (parent::choice/@minimumMultiplicity[. castable as xs:integer]) then parent::choice/@minimumMultiplicity else (0)"/>
                        <sch:let name="choicemax" value="if (parent::choice/@maximumMultiplicity[. castable as xs:integer]) then parent::choice/@maximumMultiplicity else ('*')"/>
                        <sch:let name="childmin" value="@minimumMultiplicity[string-length()>0]"/>
                        <sch:let name="childmax" value="@maximumMultiplicity[string-length()>0]"/>
                        
                        <sch:assert role="error" test="not(parent::choice) or (if ($choicemin castable as xs:integer and $childmin castable as xs:integer) then (xs:integer($childmin) le xs:integer($choicemin)) else true())"
                            >ERROR: <sch:name/>/@minimumMultiplicity '<sch:value-of select="$childmin"/>' SHALL be less than or equal to the parent choice/@minimumMultiplicity '<sch:value-of select="$choicemin"/>'.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(parent::choice) or (if ($choicemax castable as xs:integer and $childmax castable as xs:integer) then (xs:integer($childmax) le xs:integer($choicemax)) else if ($childmax='*') then ($choicemax='*') else true())"
                            >ERROR: <sch:name/>/@maximumMultiplicity '<sch:value-of select="$childmax"/>' SHALL be less than or equal to the parent choice/@maximumMultiplicity '<sch:value-of select="$choicemax"/>'.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:let name="choicemin" value="if (@minimumMultiplicity[. castable as xs:integer]) then @minimumMultiplicity else (0)"/>
                        <!--<sch:let name="choicemax" value="if (@maximumMultiplicity[. castable as xs:integer]) then @maximumMultiplicity else ('*')"/>-->
                        <sch:let name="childmin" value="sum(*/xs:integer(@minimumMultiplicity[. castable as xs:integer]))"/>
                        <!--<sch:let name="childmax" value="sum(*/xs:integer(@maximumMultiplicity[. castable as xs:integer]))"/>-->
                        <sch:assert role="error" test="not(self::choice) or $choicemin >= $childmin"
                            >ERROR: <sch:name/>/@minimumMultiplicity '<sch:value-of select="$choicemin"/>' SHALL be greater or equal than the sum of the minimumMultiplicities of its constituents '<sch:value-of select="$childmin"/>'.<sch:value-of select="$locationContext"/></sch:assert>
                        <!--<sch:assert role="error" test="not(self::choice) or $choicemax >= $childmax"
                            >ERROR: <sch:name/>/@maximumMultiplicity '<sch:value-of select="$choicemax"/>' SHALL be greater or equal than the sum of the maximumMultiplicities of its constituents '<sch:value-of select="$childmax"/>'.<sch:value-of select="$locationContext"/></sch:assert>-->
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <!-- description(s) of elements -->
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            <!-- item label, inherited by all subsequent elements unless overridden -->
            <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="include" type="IncludeDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="element" type="RuleDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <!-- DEPRECATED: <xs:element ref="references" minOccurs="0" maxOccurs="unbounded"/> -->
                <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:choice>
        </xs:sequence>
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
    </xs:complexType>
    <xs:element name="example">
        <xs:complexType mixed="true">
            <xs:sequence>
                <xs:any minOccurs="0" maxOccurs="unbounded" namespace="##any" processContents="skip"/>
            </xs:sequence>
            <xs:attribute name="type" type="ExampleType" use="optional" default="neutral">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Can be used to indicate that the instance fragment (example) is right (@type=valid) or wrong (@type=error); default is "neutral".</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Kan worden gebruikt om te markeren dat het instancefragment (voorbeeld) geldig is (@type=valid) of fout (@type=error); standaardwaarde is "neutral".</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="caption" type="NonEmptyString" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Can be used to specify a caption (string) that precedes the instance fragment (example)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="ExampleType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Type of Example given</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="error">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">ongeldig</xforms:label>
                        <xforms:label xml:lang="en-US">error</xforms:label>
                        <xforms:label xml:lang="de-DE">ungültig</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Used to indicate explicitly that the instance fragment (example) is in error.</xs:documentation>
                <xs:documentation xml:lang="nl-NL">Om aan te geven dat het een foutief instancefragment (voorbeeld) betreft.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="valid">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">geldig</xforms:label>
                        <xforms:label xml:lang="en-US">valid</xforms:label>
                        <xforms:label xml:lang="de-DE">gültig</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Used to indicate explicitly that the instance fragment (example) is valid.</xs:documentation>
                <xs:documentation xml:lang="nl-NL">Om aan te geven dat het een correct instancefragment (voorbeeld) betreft.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="neutral">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">neutraal</xforms:label>
                        <xforms:label xml:lang="en-US">neutral</xforms:label>
                        <xforms:label xml:lang="de-DE">neutral</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Used to indicate that the instance fragment (example) is not explictly stated to be right or wrong.</xs:documentation>
                <xs:documentation xml:lang="nl-NL">Om aan te geven dat het instancefragment (voorbeeld) niet expliciet geldig of ongeldig is.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <!-- DEPRECATED: <xs:element name="references">
        <!-\- references concept="2.16.840.1.113883.2.4.6.99999.90.20010" target="2.16.840.1.113883.2.4.6.99999.90.3.700" -\->
        <xs:complexType>
            <xs:attribute name="concept" type="Oid"/>
            <xs:attribute name="target" type="Oid"/>
        </xs:complexType>
    </xs:element>
    -->
    <xs:attribute name="displayName" type="NonEmptyString">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">A short description string for the designation</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    
    <!-- version handling -->
    <xs:attribute name="effectiveDate" type="TimeStampNoTimezone">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Identifies the effective date of the version of the object.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expirationDate" type="TimeStampNoTimezone">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Identifies the exiration date of the version of the object.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="officialReleaseDate" type="TimeStampNoTimezone">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Identifies the official release date of the version of the object.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="versionLabel" type="ShortDescriptiveName">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">A human readable version number or version label for convenient human rendition; not used by an application.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup name="VersionHandling">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Used to define version handling attributes</xs:documentation>
        </xs:annotation>
        <xs:attribute ref="effectiveDate" use="required"/>
        <xs:attribute ref="expirationDate" use="optional"/>
        <xs:attribute ref="officialReleaseDate" use="optional"/>
        <xs:attribute ref="versionLabel" use="optional"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="VersionHandlingEffectiveDateOptional">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Used to define version handling attributes, effective date is optional here</xs:documentation>
        </xs:annotation>
        <xs:attribute ref="effectiveDate" use="optional"/>
        <xs:attribute ref="expirationDate" use="optional"/>
        <xs:attribute ref="officialReleaseDate" use="optional"/>
        <xs:attribute ref="versionLabel" use="optional"/>
    </xs:attributeGroup>
    <xs:element name="let">
        <xs:complexType>
            <xs:attribute name="name" type="NonEmptyString" use="required"/>
            <xs:attribute name="value" type="NonEmptyString" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="assert">
        <xs:complexType mixed="true">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:any processContents="skip"/>
            </xs:sequence>
            <xs:attribute name="flag" type="NonEmptyString" use="optional"/>
            <xs:attribute name="see" type="NonEmptyString" use="optional"/>
            <xs:attribute name="role" type="AssertRole" use="required"/>
            <xs:attribute name="test" type="NonEmptyString" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="report">
        <xs:complexType mixed="true">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:any processContents="skip"/>
            </xs:sequence>
            <xs:attribute name="flag" type="NonEmptyString" use="optional"/>
            <xs:attribute name="see" type="NonEmptyString" use="optional"/>
            <xs:attribute name="role" type="AssertRole" use="required"/>
            <xs:attribute name="test" type="NonEmptyString" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="defineVariable">
        <xs:complexType mixed="true">
            <xs:sequence>
                <xs:element name="code" minOccurs="0" maxOccurs="1" type="VarCode"/>
                <xs:element name="use" minOccurs="0" maxOccurs="1" type="VarUse"/>
            </xs:sequence>
            <xs:attribute name="name" type="xs:NCName" use="required"/>
            <xs:attribute name="path" type="xs:anyURI" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="VarCode">
        <xs:attribute name="code" use="required" type="EnumerationString"/>
        <xs:attribute name="codeSystem" use="required" type="Oid"/>
    </xs:complexType>
    <xs:complexType name="VarUse">
        <xs:attribute name="path" use="required" type="xs:anyURI"/>
        <xs:attribute name="as" use="required" type="DatatypeName"/>
    </xs:complexType>
    <xs:simpleType name="AssertRole">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Type of assertion (schematron)</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="fatal">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Fatal</xforms:label>
                        <xforms:label xml:lang="nl-NL">Fataal</xforms:label>
                        <xforms:label xml:lang="de-DE">Fatal</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="error">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Error</xforms:label>
                        <xforms:label xml:lang="nl-NL">Fout</xforms:label>
                        <xforms:label xml:lang="de-DE">Fehler</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="warning">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Warning</xforms:label>
                        <xforms:label xml:lang="nl-NL">Waarschuwing</xforms:label>
                        <xforms:label xml:lang="de-DE">Warnung</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="hint">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Hint</xforms:label>
                        <xforms:label xml:lang="nl-NL">Hint</xforms:label>
                        <xforms:label xml:lang="de-DE">Hint</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="item">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:sequence>
            <xs:attribute name="label" type="NonEmptyString" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="context">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Template/context</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]/context">
                        <sch:let name="locationContext" value="concat(' | Location &lt;template ', string-join(for $att in ancestor-or-self::template[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:assert role="error" test="not(@id and @path)"
                            >ERROR: Template/context SHALL have @id or @path, not both.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <!-- Was: SelfReferenceTemplateIdOrOid, but the Oid construct never made it into the template DSTU and is not currently in use or supported by DECOR2Schematron -->
            <xs:attribute name="id" use="optional" type="SelfReferenceTemplateId"/>
            <xs:attribute name="path" use="optional" type="PathType"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="PathType">
        <xs:union memberTypes="PathTypeSlash xs:anyURI"/>
    </xs:simpleType>
    <xs:simpleType name="PathTypeSlash">
        <xs:restriction base="xs:string">
            <xs:enumeration value="/">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Path starts at root node</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="//">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Path starts at any node</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="SelfReferenceTemplateId">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Used as the type of a context template id</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="*">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Scope is templateId</xforms:label>
                        <xforms:label xml:lang="nl-NL">Scope is templateId</xforms:label>
                        <xforms:label xml:lang="de-DE">Scope is templateId</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">template scope is templateId element and sibling nodes. Requires a top level element templateId with the same id as the template itself</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="**">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Scope is top level element</xforms:label>
                        <xforms:label xml:lang="nl-NL">Scope is top level element</xforms:label>
                        <xforms:label xml:lang="de-DE">Scope is top level element</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">template scope is top level element with templateId element and child nodes. Requires that the template has one top level element and an element templateId with the same id as the template itself as child of that top level element</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="SelfReferenceTemplateIdOrOid">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">a string "*" or "**" or a valid Oid. The value * requires a top level element templateId with the same id as the template itself. The value ** requires that the template has one top level element and an element templateId with the same id as the template itself as child of that top level element. When context/@id contains an Oid, the template requires requires a top level element templateId with that same id</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="SelfReferenceTemplateId Oid"/>
    </xs:simpleType>
    <xs:element name="pathname">
        <xs:complexType>
            <xs:attribute name="path" use="required" type="Uri"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="DecimalRange">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">A real number that is restricted to a maximum of 10 characters, and may have no more than 5 decimal places.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:decimal">
            <xs:maxExclusive value="1000000000"/>
            <xs:minInclusive value="-1000000000"/>
            <xs:fractionDigits value="5"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="IntegerRange">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">An integer number that is restricted to a maximum of 10 characters</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:maxExclusive value="1000000000"/>
            <xs:minInclusive value="-1000000000"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="IntegerOrDecimalRange">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">An integer or decimal range</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="IntegerRange DecimalRange"/>
    </xs:simpleType>
    <xs:element name="cardinality">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <!--
                    <sch:pattern>
                        <sch:title>Validate Cardinality</sch:title>
                        <sch:rule context="cardinality">
                            <sch:extends rule="MultiplicityRange"/>
                        </sch:rule>
                    </sch:pattern>
                    -->
                </xs:appinfo>
            </xs:annotation>
            <xs:attributeGroup ref="MultiplicityRangeRequired"/>
            <xs:attribute name="conformance" type="ConformanceType"/>
            <xs:attribute name="isMandatory" type="xs:boolean" default="false"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="attribute">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Attribute</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//attribute">
                        <sch:let name="locationContext" value="concat(' | Location &lt;template ', string-join(for $att in ancestor-or-self::template[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <!--sch:assert role="warning" test="not(@datatype)"
                            >WARNING: The datatype SHOULD be specified on "element". Specification on "attribute" has been deprecated.<sch:value-of select="$locationContext"/></sch:assert>-->
                        <!--sch:assert role="error" test="@datatype = parent::element/@datatype or not(@datatype) or not(parent::element/@datatype)"
                            >ERROR: The datatype on "attribute" SHALL be equal to the datatype on "element".<sch:value-of select="$locationContext"/></sch:assert>-->
                        <!--sch:assert role="warning" test="not(vocabulary)"
                            >WARNING: The vocabalary elements SHOULD be immediate children of "element". Specification as children of "attribute" has been deprecated.<sch:value-of select="$locationContext"/></sch:assert>-->
                        <!--<sch:assert role="error" test="not(@name or @value) or (@name and (@value or vocabulary))"
                            >ERROR: attribute MUST have both @name and (@value or vocabulary), or neither..<sch:value-of select="$locationContext"/></sch:assert>
                            -->
                        <!--
                        <sch:assert role="warning" test="not(@unit or @name='unit')"
                            >WARNING: attribute specifies @unit. This attribute SHOULD be specified through <property unit="..."/>.<sch:value-of select="$locationContext"/></sch:assert>
                        -->
                        <sch:let name="format" value="if (ancestor::template/classification/@format) then (ancestor::template/classification/@format)[1] else ('hl7v3xml1')"/>
                        <sch:let name="artdecor" value="'http://art-decor.org/ADAR/rv/'"/>
                        <sch:let name="datatypeFile" value="if ($format = 'hl7v3xml1') then ('DECOR-supported-datatypes.xml') else concat('DECOR-supported-datatypes-',$format,'.xml')"/>
                        <!-- Extra $artdecor is necessary for supported in check-decor.xquery that will not resolve the file next to us (...sigh) -->
                        <sch:let name="supportedDatatypes" value="if (doc-available($datatypeFile)) then doc($datatypeFile) else if (doc-available(concat($artdecor,$datatypeFile))) then doc(concat($artdecor,$datatypeFile)) else ()"/>
                        
                        <!--<sch:let name="dtNsURI" value="if (contains(@datatype,':')) then namespace-uri-for-prefix(substring-before(@datatype,':')) else ('urn:hl7-org:v3')"/>-->
                        <sch:let name="dt" value="@datatype"/>
                        <sch:let name="val" value="@value"/>
                        <sch:let name="dtName" value="if (contains($dt,':')) then substring-after($dt,':') else ($dt)"/>
                        <sch:let name="parentDtName" value="if (contains(parent::*/@datatype,':')) then substring-after(parent::*/@datatype,':') else (parent::*/@datatype)"/>
                        <sch:let name="xsiDtName" value="if (contains(.[@name='xsi:type']/@value,':')) then substring-after(.[@name='xsi:type']/@value,':') else (.[@name='xsi:type']/@value)"/>
                        <sch:let name="dtIsFlavorAndXsiIsDatatype" value="if ($supportedDatatypes) then (exists($supportedDatatypes//(dataType|flavor)[@name=$parentDtName]/ancestor-or-self::dataType[@name=$xsiDtName])) else (true())"/>
                        
                        <sch:assert role="error" test="not(@name) or matches(@name, '^([^:\s]+:)?[^\d][A-Za-z\d\._-]*$')"
                            >ERROR: Template attribute/@name='<sch:value-of select="@name"/>' SHALL be a valid QName.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="warning" test="not($parentDtName and $xsiDtName) or $dtIsFlavorAndXsiIsDatatype"
                            >WARNING: Template attribute @xsi:type SHOULD NOT specify a value '<sch:value-of select="$xsiDtName"/>', or SHOULD specify a value that matches the element definition '<sch:value-of select="$parentDtName"/>', or SHOULD specify a value that matches the base datatype when the element definition specifies a flavor.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="warning" test="not(@classCode|@contextConductionInd|@contextControlCode|@determinerCode|@extension|@independentInd|@institutionSpecified|@inversionInd|@mediaType|@moodCode|@negationInd|@nullFlavor|@operator|@qualifier|@representation|@root|@typeCode|@unit|@use)"
                            >WARNING: Template attribute shorthand for HL7 V3 attribute found. Use is discouraged, please use @name='..' and optionally @value='..' instead.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not((@classCode|@contextConductionInd|@contextControlCode|@determinerCode|@extension|@independentInd|@institutionSpecified|@inversionInd|@mediaType|@moodCode|@negationInd|@nullFlavor|@operator|@qualifier|@representation|@root|@typeCode|@unit|@use)[contains(.,'|')])"
                            >ERROR: Template attribute cannot define a choice for its value. Please use @name.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(count(@classCode|@contextConductionInd|@contextControlCode|@determinerCode|@extension|@independentInd|@institutionSpecified|@inversionInd|@mediaType|@moodCode|@negationInd|@nullFlavor|@operator|@qualifier|@representation|@root|@typeCode|@unit|@use)>1 and @id)"
                            >ERROR: Template attribute with multiple shorthands SHALL NOT have @id as that would be ambiguous.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <!-- Background: the check on valueSet does not consider code(System)s in the other vocabulary element and vice versa. So there will be errors about a valid codeSystem or a valid code regardless -->
                        <!--<sch:assert role="warning" test="not(vocabulary[@valueSet] and vocabulary[@code or @codeSystem])"
                            >WARNING: combining vocabulary definitions based on a valueSet and based on a @code and/or @codeSystem is currently not supported in the schematron engine. Consider creating a valueSet that supports the specified combination.<sch:value-of select="$locationContext"/></sch:assert>-->
                        
                        <!--<sch:assert role="error" test="not(@id) or count(index-of(ancestor::template//@id,@id))=1"
                            >ERROR: Template attribute/@id='<sch:value-of select="@id"/>' SHALL be unique within the template (version). Found <sch:value-of select="count(index-of(ancestor::template//@id,@id))"/> occurrences.<sch:value-of select="$locationContext"/></sch:assert>-->
                        
                        <sch:assert role="error" test="not($supportedDatatypes) or not(@datatype) or $supportedDatatypes//(atomicDataType|flavor)[@name=($dt,$dtName)]"
                            >ERROR: Template attribute/@datatype '<sch:value-of select="@datatype"/>' SHALL be a supported datatype (reference file: <sch:value-of select="$datatypeFile"/>).<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:assert role="error" test="not(contains(@value,'|'))"
                            >ERROR: Template attribute/@name='<sch:value-of select="@name"/>' SHOULD NOT have a choice as its @value ('<sch:value-of select="@value"/>'). The schematron engine will NOT support that and treat it as a literal string.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:assert role="error" test="true()=(
                            for $att in (@name, (@classCode|@contextConductionInd|@contextControlCode|@determinerCode|@extension|@independentInd|@institutionSpecified|@inversionInd|@mediaType|@moodCode|@negationInd|@nullFlavor|@operator|@qualifier|@representation|@root|@typeCode|@unit|@use)/name()) 
                                return count(../attribute[@name=$att or @*[not(name()=('name','value','isOptional','prohibited','datatype','id'))]/name()=$att])=1)"
                            >ERROR: Template attribute SHALL NOT be defined more than once on the same element.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <!-- pattern definitions -->
                        <sch:let name="INTdigits" value="'^-?[1-9]\d*$|^+?\d*$'"/>
                        <sch:let name="REALdigits" value="'^[-+]?\d*\.?[0-9]+([eE][-+]?\d+)?$'"/>
                        <sch:let name="OIDpattern" value="'^[0-2](\.(0|[1-9]\d*))*$'"/>
                        <sch:let name="RUIDpattern" value="'^[A-Za-z][A-Za-z\d\-]*$'"/>
                        <!-- Abstract datatypes 2.15.1
                            The literal form for the UUID is defined according to the original specification of the UUID. 
                            However, because the HL7 UIDs are case sensitive, for use with HL7, the hexadecimal digits A-F 
                            in UUIDs must be converted to upper case.
                            
                            This being said: if we were to hold current implementations to this idea, then a lot would be 
                            broken and not even the official HL7 datatypes check this requirement. Hence we knowingly allow 
                            lower-case a-f.
                        -->
                        <sch:let name="UUIDpattern" value="'^[A-Fa-f\d]{8}-[A-Fa-f\d]{4}-[A-Fa-f\d]{4}-[A-Fa-f\d]{4}-[A-Fa-f\d]{12}$'"/>
                        <sch:let name="TSpattern" value="'^[0-9]{4,14}'"/>
                        
                        <sch:assert role="error" test="not($dt = ('bl','bn')) or not($val) or $val = ('true','false')"
                            >ERROR: Template attribute <sch:value-of select="@name"/>='<sch:value-of select="$val"/>' SHALL match the specified datatype '<sch:value-of select="$dt"/>' (true or false)</sch:assert>
                        <sch:assert role="error" test="not($dt = ('uid')) or not($val) or matches($val, $OIDpattern) or matches($val, $UUIDpattern) or matches($val, $RUIDpattern)"
                            >ERROR: Template attribute <sch:value-of select="@name"/>='<sch:value-of select="$val"/>' SHALL match the specified datatype '<sch:value-of select="$dt"/>' (OID, UUID or RUID)</sch:assert>
                        <sch:assert role="error" test="not(@codeSystem) or matches($val, $OIDpattern) or matches($val, $UUIDpattern) or matches($val, $RUIDpattern)"
                            >ERROR: Template attribute codeSystem='<sch:value-of select="@codeSystem"/>' SHALL match the datatype 'uid' (OID, UUID or RUID)</sch:assert>
                        <sch:assert role="error" test="not($dt = ('oid')) or not($val) or matches($val, $OIDpattern)"
                            >ERROR: Template attribute <sch:value-of select="@name"/>='<sch:value-of select="$val"/>' SHALL match the specified datatype '<sch:value-of select="$dt"/>'</sch:assert>
                        <sch:assert role="error" test="not($dt = ('uuid')) or not($val) or matches($val, $UUIDpattern)"
                            >ERROR: Template attribute <sch:value-of select="@name"/>='<sch:value-of select="$val"/>' SHALL match the specified datatype '<sch:value-of select="$dt"/>'</sch:assert>
                        <sch:assert role="error" test="not($dt = ('ruid')) or not($val) or matches($val, $RUIDpattern)"
                            >ERROR: Template attribute <sch:value-of select="@name"/>='<sch:value-of select="$val"/>' SHALL match the specified datatype '<sch:value-of select="$dt"/>'</sch:assert>
                        <sch:assert role="error" test="not($dt = ('cs')) or not($val) or not(matches($val, '\s'))"
                            >ERROR: Template attribute <sch:value-of select="@name"/>='<sch:value-of select="$val"/>' SHALL match the specified datatype '<sch:value-of select="$dt"/>' (no whitespace)</sch:assert>
                        <sch:assert role="error" test="not(@code) or not(matches($val, '\s'))"
                            >ERROR: Template attribute code='<sch:value-of select="@code"/>' SHALL match the datatype 'cs' (no whitespace)</sch:assert>
                        <sch:assert role="error" test="not($dt = ('ts')) or not($val) or matches($val, $TSpattern)"
                            >ERROR: Template attribute <sch:value-of select="@name"/>='<sch:value-of select="$val"/>' SHALL match the specified datatype '<sch:value-of select="$dt"/>'</sch:assert>
                        <sch:assert role="error" test="not($dt = ('int')) or not($val) or matches($val, $INTdigits)"
                            >ERROR: Template attribute <sch:value-of select="@name"/>='<sch:value-of select="$val"/>' SHALL match the specified datatype '<sch:value-of select="$dt"/>'</sch:assert>
                        <sch:assert role="error" test="not($dt = ('real')) or not($val) or matches($val, $REALdigits)"
                            >ERROR: Template attribute <sch:value-of select="@name"/>='<sch:value-of select="$val"/>' SHALL match the specified datatype '<sch:value-of select="$dt"/>'</sch:assert>
                        <sch:assert role="error" test="not($dt = ('url')) or not($val) or $val castable as xs:anyURI"
                            >ERROR: Template attribute <sch:value-of select="@name"/>='<sch:value-of select="$val"/>' SHALL match the specified datatype '<sch:value-of select="$dt"/>'</sch:assert>
                        <!-- CDA -->
                        <!-- eXist-db 2.2 (2017-05-25) When you use "castable as". it leads to a seemingly unrelated error in decor-check.xquery due to Saxon-PE:
                             <exception>
                                <path>/db/apps/art/modules/check-decor.xquery</path>
                                <message>exerr:ERROR Exception while transforming node: Ambiguous rule match for /decor/datasets[1]/dataset[1]/concept[1]
                                    ERROR XFormsServer  -     Matches both "datasets/dataset//concept[not(ancestor::history)][not(parent::conceptList)][@id]" on line -1 of 
                                    ERROR XFormsServer  -     and "node()" on line -1 of  [at line 42, column 40]
                                    ERROR XFormsServer  -     In function:
                                    ERROR XFormsServer  -     	local:validate-iso-schematron-svrl(item(), item()) [115:17:/db/apps/art/modules/check-decor.xquery]</message>
                             </exception>
                        -->
                        <sch:assert role="error" test="not($dt = ('xs:ID')) or not($val) or matches($val, '^([\i-[:]][\c-[:]]*)$')"
                            >ERROR: Template attribute <sch:value-of select="@name"/>='<sch:value-of select="$val"/>' SHALL match the specified datatype '<sch:value-of select="$dt"/>'</sch:assert>
                        <sch:assert role="error" test="not($dt = ('xs:IDREF')) or not($val) or matches($val, '^([\i-[:]][\c-[:]]*)$')"
                            >ERROR: Template attribute <sch:value-of select="@name"/>='<sch:value-of select="$val"/>' SHALL match the specified datatype '<sch:value-of select="$dt"/>'</sch:assert>
                        <!-- this needs xpath 3.0 enabled -->
                        <sch:assert role="error" test="not($dt = ('xs:IDREFS')) or not($val) or matches($val, '^([\i-[:]][\c-[:]]*)+( [\i-[:]][\c-[:]]*)*$')"
                            >ERROR: Template attribute <sch:value-of select="@name"/>='<sch:value-of select="$val"/>' SHALL match the specified datatype '<sch:value-of select="$dt"/>'</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
                <!-- item label, inherited by all subsequent elements unless overridden -->
                <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
                
                <xs:choice>
                    <xs:element ref="vocabulary" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
                </xs:choice>
                
                <!-- constraints for attributes of type "coded" or "quantities"??????? -->
                <!-- 
                    <xs:choice maxOccurs="1">
                    <xs:element ref="vocabulary" minOccurs="0" maxOccurs="1"/>
                    <xs:element ref="property" minOccurs="0" maxOccurs="1"/>
                </xs:choice>
                -->
            </xs:sequence>
            
            <!-- == start definitional attributes -->
            <!-- name of attributes required (name) -->
            <xs:attribute name="name" type="EnumerationToken"/>
            
            <!-- data type II: elements where other siblings are allowed -->
            <xs:attribute name="value" type="NonEmptyString"/>
            <!-- == end definitional attributes -->
            
            <!-- == start shorthand attributes (discouraged) == -->
            <!-- (@classCode|@contextConductionInd|@contextControlCode|@determinerCode|
                  @extension|@independentInd|@institutionSpecified|@inversionInd|
                  @mediaType|@moodCode|@negationInd|@nullFlavor|
                  @operator|@qualifier|@representation|@root|
                  @typeCode|@unit|@use) -->
            <xs:attribute name="classCode" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="contextConductionInd" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="contextControlCode" type="EnumerationToken">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="determinerCode" type="EnumerationToken">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="extension" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="independentInd" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="institutionSpecified" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="inversionInd" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="mediaType" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="moodCode" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="negationInd" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="nullFlavor" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="operator" type="EnumerationToken">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="qualifier" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="representation" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="root" type="OidChoiceList">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="typeCode" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="unit" type="NonEmptyString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="use" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- == end shorthand attributes (discouraged) == -->
            
            <!-- == start attribute properties == -->
            
            <xs:attribute name="isOptional" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Determines that the attribute is requird to be in the instance. Default is 'false', meaning that the attribute is NOT optional, and thus required.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="prohibited" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Determines that the attribute is prohibited to be in the instance.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <!--<xs:attribute name="datatype" type="AttributeDatatypeName"/>-->
            <xs:attribute name="datatype" type="xs:QName">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Determines the datatype of the attribute in the instance.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- == end attributes properties == -->
            
            <!-- == start DECOR internal purpose only == -->
            <!-- 20141215 - an optional id for to be referenced by associated concepts -->
            <xs:attribute name="id" type="Oid"/>
            <!-- == end DECOR internal purpose only == -->
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="AttributeDatatypeName">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Used for datatype names of attributes only</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:maxLength value="60"/>
            <xs:pattern value="[a-z_]+(.[a-z]+)*(.diffType)?"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="property">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate Property</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//element/property">
                        <sch:let name="locationContext" value="concat(' | Location &lt;template ', string-join(for $att in ancestor-or-self::template[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:assert role="error" test="
                            count(@* except (@unit|@minInclude|@maxInclude|@fractionDigits))=0 or 
                            count(@* except (@currency|@minInclude|@maxInclude|@fractionDigits))=0 or 
                            count(@* except (@minLength|@maxLength))=0 or 
                            count(@* except (@value))=0"
                            >ERROR: Template element property SHALL contain any of these combinations of attributes: (@unit @minInclude @maxInclude @fractionDigits) or (@currency @minInclude @maxInclude @fractionDigits) or (@minLength @maxLength) or (@value)<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">Used for attributes of type "quantity", "string" or "boolean". Allows assertion of one or more units, ranges, fraction digits or fixed values. Valid
                combinations of attributes are: <li>
                    <ul>@unit @minInclude @maxInclude @fractionDigits</ul>
                    <ul>@currency @minInclude @maxInclude @fractionDigits</ul>
                    <ul>@minLength @maxLength</ul>
                    <ul>@value</ul>
                </li>
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>

            <!-- quantity constraints -->
            <xs:attribute name="unit" type="NonEmptyString"/>
            <xs:attribute name="currency" type="NonEmptyString"/>
            <xs:attribute name="minInclude" type="IntegerOrDecimalRange"/>
            <xs:attribute name="maxInclude" type="IntegerOrDecimalRange"/>
            <xs:attribute name="fractionDigits" type="FractionDigitsType"/>

            <!-- string constraints -->
            <xs:attribute name="minLength" type="SmallNonNegativeInteger"/>
            <xs:attribute name="maxLength" type="SmallNonNegativeInteger"/>

            <!-- fixed values -->
            <xs:attribute name="value" type="NonEmptyString"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="FractionDigitsType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Value Domain Time Stamp Precision</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="\d{1,4}[!]{0,1}"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="vocabulary">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Attribute Vocabulary</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//attribute/vocabulary">
                        <sch:let name="locationContext" value="concat(' | Location &lt;template ', string-join(for $att in ancestor-or-self::template[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:let name="projectId" value="ancestor::decor/project/@id"/>
                        <sch:let name="vsid" value="@valueSet"/>
                        <sch:let name="matches" value="//terminology/valueSet[(@id,@name)=$vsid]/xs:dateTime(@effectiveDate)"/>
                        <sch:let name="vsed" value="if (matches(@flexibility,'^\d{4}')) then (@flexibility) else (max($matches))"/>
                        <sch:let name="vs" value="//terminology/valueSet[(@id|@ref|@name)=$vsid][@ref or @effectiveDate=$vsed]"/>
                        
                        <sch:assert role="error" test="count(@* except (@valueSet|@flexibility|@code))=0"
                            >ERROR: <sch:value-of select="name(..)"/>/<sch:name/> SHALL NOT have other attributes than @valueSet, @flexibility or @code.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@valueSet) or count(@* except (@valueSet|@flexibility))=0"
                            >ERROR: <sch:value-of select="name(..)"/>/<sch:name/>/@valueSet SHALL NOT co-occur with any other attribute than @flexibility.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@domain) or count(@* except (@domain))=0"
                            >ERROR: <sch:name/>/@domain SHALL NOT co-occur with any other attribute.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:assert role="error" test="if ($vsid and (starts-with($vsid, concat($projectId,'.')) or ancestor::decor[@versionDate])) then $vs else (true())"
                            >ERROR: Template vocabulary SHALL point to an existing valueSet '<sch:value-of select="$vsid"/>' and if applicable with the correct @flexibility.<sch:value-of select="if (ancestor::decor[@versionDate]) then (' In a compiled project, all references are expected to be resolved.') else (' The artifact would appear to be part of your project based on id. It might be resolved during pre-publication compile phase, regardless of a reference, but they will not be in your list of artifacts in ART while there is no reference.')"/><sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="info" test="if ($vsid and not(starts-with($vsid,concat($projectId,'.')) or ancestor::decor[@versionDate])) then $vs else (true())"
                            >INFO: Template vocabulary SHOULD point to an existing valueSet '<sch:value-of select="$vsid"/>' and if applicable with the correct @flexibility. Note that in the pre-publication compile phase these references will be resolved if possible, regardless of a reference, but they will not be in your list of artifacts in ART while there is no reference.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="warning" test="not($vsid) or matches($vsid,'^[0-9\.]+$')"
                            >WARNING: Template vocabulary/@valueSet='<sch:value-of select="$vsid"/>' references SHOULD be based on valueSet/@id. References by @name quickly become ambiguous.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//element/vocabulary">
                        <sch:let name="locationContext" value="concat(' | Location &lt;template ', string-join(for $att in ancestor-or-self::template[1]/(@id, @ref, @name, name[string-length()>0][1], @displayName, @effectiveDate, @flexibility) return concat(name($att),'=&quot;',$att,'&quot;'),' '),'/&gt;')"/>
                        
                        <sch:assert role="error" test="not(@valueSet) or count(@* except (@valueSet|@flexibility))=0"
                            >ERROR: Template vocabulary/@valueSet SHALL NOT co-occur with any other attribute than @flexibility.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="error" test="not(@domain) or count(@* except (@domain))=0"
                            >ERROR: Template vocabulary/@domain SHALL NOT co-occur with any other attribute.<sch:value-of select="$locationContext"/></sch:assert>
                        
                        <sch:let name="projectId" value="ancestor::decor/project/@id"/>
                        <sch:let name="vsid" value="@valueSet"/>
                        <sch:let name="matches" value="//terminology/valueSet[(@id,@name)=$vsid]/xs:dateTime(@effectiveDate)"/>
                        <sch:let name="vsed" value="if (matches(@flexibility,'^\d{4}')) then (@flexibility) else (max($matches))"/>
                        
                        <sch:let name="vsedtext" value="if (matches(@flexibility,'^\d{4}')) then @flexibility else ('dynamic')"/>
                        <sch:let name="vs" value="//terminology/valueSet[(@id|@ref|@name)=$vsid][@ref or @effectiveDate=$vsed]"/>
                        
                        <sch:assert role="error" test="if ($vsid and (starts-with($vsid, concat($projectId,'.')) or ancestor::decor[@versionDate])) then $vs else (true())"
                            >ERROR: Template vocabulary SHALL point to an existing valueSet '<sch:value-of select="$vsid"/>' and if applicable with the correct @flexibility.<sch:value-of select="if (ancestor::decor[@versionDate]) then (' In a compiled project, all references are expected to be resolved.') else (' The artifact would appear to be part of your project based on id. It might be resolved during pre-publication compile phase, regardless of a reference, but they will not be in your list of artifacts in ART while there is no reference.')"/><sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="info" test="if ($vsid and not(starts-with($vsid,concat($projectId,'.')) or ancestor::decor[@versionDate])) then $vs else (true())"
                            >INFO: Template vocabulary SHOULD point to an existing valueSet '<sch:value-of select="$vsid"/>' and if applicable with the correct @flexibility. Note that in the pre-publication compile phase these references will be resolved if possible, regardless of a reference, but they will not be in your list of artifacts in ART while there is no reference.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="warning" test=" not($vsid) or not($vs[@id]/conceptList/(exception|insert[@exception='true']) and parent::element[@isMandatory='true'])"
                            >WARNING: Template vocabulary/@valueSet '<sch:value-of select="$vsid"/>' (<sch:value-of select="$vsedtext"/>) contains exceptions, but element has @isMandatory='true'. This renders those exceptions invalid in this context.<sch:value-of select="$locationContext"/></sch:assert>
                        <!-- cannot check valueSet/@ref so make exception for that situation... -->
                        <sch:assert role="warning" test="not($vs[@id]) or $vs[@id]/conceptList/(exception|include[@exception='true']) or parent::element[@isMandatory='true'] or not(parent::element[number(@minimumMultiplicity) > 0]) or ../attribute[@name = 'nullFlavor' or @nullFlavor][@prohibited = 'true']"
                            >WARNING: Template vocabulary/@valueSet '<sch:value-of select="$vsid"/>' (<sch:value-of select="$vsedtext"/>) does not contain exceptions, but element has @minimumMultiplicity > 0. This effectively places all nullFlavors in scope, making it harder to implement.<sch:value-of select="$locationContext"/></sch:assert>
                        <sch:assert role="warning" test="not($vsid) or matches(@valueSet,'^[0-9\.]+$')"
                            >WARNING: Template vocabulary/@valueSet='<sch:value-of select="$vsid"/>' references SHOULD be based on template/@id. References by @name quickly become ambiguous.<sch:value-of select="$locationContext"/></sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">Used for attributes of "coded" types. Allows assertion of one or more codes, code systems or value sets.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <!-- value set assertions -->
            <xs:attribute name="valueSet" type="BasicIdOrOid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a valueSet/@id or @name. References to @name are discouraged because they become ambiguous quickly.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a valueSet/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
                </xs:annotation>
            </xs:attribute>

            <!-- code constraints -->
            <xs:attribute name="code" type="EnumerationString" use="optional"/>
            <xs:attribute name="codeSystem" type="Oid" use="optional"/>

            <!-- other constraints -->
            <xs:attribute ref="displayName" use="optional"/>
            <xs:attribute name="codeSystemName" type="NonEmptyString" use="optional"/>
            
            <!-- concept domain (a sinple string as an "abstract" indication only) -->
            <xs:attribute name="domain" type="NonEmptyString" use="optional"/>
            
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="CodingStrengthType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Coding strength of a vocabulary binding</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="CNE">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">deprecated: use required. Required/CNE. Coded with no exceptions; this element SHALL be from the specified value set</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">deprecated: gebruik required. Verplicht/CNE. Gecodeerd, geen uitzonderingen; dit element MOET uit de gespecificeerde waardenlijst komen</xs:documentation>
                    <xs:documentation xml:lang="de-DE">deprecated: use required. Erforderlich/CNE. Codiert, keine Ausnahmen; das Element muss aus dem angegebene Value Set kommen.</xs:documentation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Required/CNE</xforms:label>
                        <xforms:label xml:lang="nl-NL">Verplicht/CNE</xforms:label>
                        <xforms:label xml:lang="de-DE">Erforderlich/CNE</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Required/CNE. Coded with no exceptions; this element SHALL be from the specified value set</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Verplicht/CNE. Gecodeerd, geen uitzonderingen; dit element MOET uit de gespecificeerde waardenlijst komen</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Erforderlich/CNE. Codiert, keine Ausnahmen; das Element muss aus dem angegebene Value Set kommen.</xs:documentation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Required/CNE</xforms:label>
                        <xforms:label xml:lang="nl-NL">Verplicht/CNE</xforms:label>
                        <xforms:label xml:lang="de-DE">Erforderlich/CNE</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CWE">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">deprecated, use extensible. Extensible/CWE. Coded with Exceptions; this element SHALL be from the specified value set if any of the codes within the value set can apply to the concept being communicated. If the value set does not cover the concept (based on human review), alternate codings (or, data type allowing, text) may be included instead.</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">deprecated, gebruik extensible. Uitbreidbaar/CWE. Gecodeerde uitzonderingen toegestaan; dit element MOET uit de gespecificeerde waardenlijst komen als een van de codes binnen de waardenlijst van toepassing is op het concept dat wordt gecommuniceerd. Als de waarde het concept niet dekt (op basis van menselijke beoordeling), kunnen in plaats daarvan alternatieve coderingen (of datatype waarmee wordt toegestaan, tekst) worden opgenomen.</xs:documentation>
                    <xs:documentation xml:lang="de-DE">deprecated, use extensible. Erweiterbar/CWE. Codiert, Ausnahmen zugelassen; Dieses Element sollte aus dem angegebenen Value Set kommen, wenn das Konzept kommuniziert wird. Wenn der Code das Konzept nicht abdeckt (basierend auf menschlicher Überprüfung), können alternative Kodierungen (oder falls der Datentyp es erlaubt, Text) eingeschlossen sein.</xs:documentation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Extensible/CWE</xforms:label>
                        <xforms:label xml:lang="nl-NL">Uitbreidbaar/CWE</xforms:label>
                        <xforms:label xml:lang="de-DE">Erweiterbar/CWE</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="extensible">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Extensible/CWE. Coded with Exceptions; this element SHALL be from the specified value set if any of the codes within the value set can apply to the concept being communicated. If the value set does not cover the concept (based on human review), alternate codings (or, data type allowing, text) may be included instead.</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Uitbreidbaar/CWE. Gecodeerde uitzonderingen toegestaan; dit element MOET uit de gespecificeerde waardenlijst komen als een van de codes binnen de value set van toepassing is op het concept dat wordt gecommuniceerd. Als de waarde het concept niet dekt (op basis van menselijke beoordeling), kunnen in plaats daarvan alternatieve coderingen (of datatype waarmee wordt toegestaan, tekst) worden opgenomen.</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Erweiterbar/CWE. Codiert, Ausnahmen zugelassen; Dieses Element sollte aus dem angegebenen Value Set kommen, wenn das Konzept kommuniziert wird. Wenn der Code das Konzept nicht abdeckt (basierend auf menschlicher Überprüfung), können alternative Kodierungen (oder falls der Datentyp es erlaubt, Text) eingeschlossen sein.</xs:documentation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Extensible/CWE</xforms:label>
                        <xforms:label xml:lang="nl-NL">Uitbreidbaar/CWE</xforms:label>
                        <xforms:label xml:lang="de-DE">Erweiterbar/CWE</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="preferred">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Preferred. Instances are encouraged to draw from the specified codes for interoperability purposes but are not required to do so to be considered conformant.</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Voorkeur. Instantiaties worden aangemoedigd om voor interoperabiliteitsdoeleinden codes op basis van de gespecificeerde waardenlijst te gebruiken.</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Bevorzugt. Instanzen werden aufgefordert, für Interoperabilitätszwecke die Codes aus dem Value Set zu nutzen.</xs:documentation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Preferred</xforms:label>
                        <xforms:label xml:lang="nl-NL">Voorkeur</xforms:label>
                        <xforms:label xml:lang="de-DE">Bevorzugt</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="example">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Example. Instances are not expected or even encouraged to draw from the specified value set. The value set merely provides examples of the types of concepts intended to be included.</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Voorbeeld. Instantiaties worden niet verwacht of zelfs maar aangemoedigd om codes op basis van de gespecificeerde waardenlijst te gebruiken. De waardenlijst stelt een voorbeeld voor van het type concept dat gebruikt kan worden.</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Beispiel. Es wird in Instanzen nicht erwartet, dass der Code aus  dem Value Set genutzt wird. Das Value Set enthält Beispiele für den Typ Konzept, die verwendet werden können.</xs:documentation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">Example</xforms:label>
                        <xforms:label xml:lang="nl-NL">Voorbeeld</xforms:label>
                        <xforms:label xml:lang="de-DE">Beispiel</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    
    <!-- =================================== -->
    
    <!-- =================================== -->
    <!-- COMPILATION ADDED STUFF -->
    <!-- versionDate="2015-03-18T11:10:06" versionLabel="" compilationDate="2015-03-18T11:10:06" language="nl-NL" deeplinkprefix="http://localhost:8080/art-decor/" deeplinkprefixservices="http://localhost:8877/decor/services/" -->
    <xs:attributeGroup name="ProvenanceCompilationAttributes">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Additional compilation attributes on the dataset, template and valueSet element</xs:documentation>
        </xs:annotation>
        <xs:attribute name="url" type="xs:anyURI" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the services URL useful in retrieving the dataset, template, or value set</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ident" type="ShortDescriptiveName" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the project @prefix of the project that defines the dataset, template, or value set</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="referencedFrom" type="ShortDescriptiveName" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the project @prefix of the project that referenced the dataset, template, or value set (normally current project)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="DecorCompilationAttributes">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Additional compilation attributes on the decor root element</xs:documentation>
        </xs:annotation>
        <xs:attribute name="versionDate" type="TimeStampNoTimezoneOrDevelopment" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the date stamp or 'development' for the currently processed project/(version|release)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="versionLabel" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the label for the currently processed project/(version|release)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="compilationDate" type="TimeStampNoTimezoneOrDevelopment" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the date stamp or 'development' of the compilation process</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="language" type="LanguageCode" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains principal used in the compilation process (compilation may be run multiple times, one per language)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="deeplinkprefix" type="xs:anyURI" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains ART-DECOR URI of the server that ran the compilation.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="deeplinkprefixservices" type="xs:anyURI" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains DECOR services URI of the server that ran the compilation.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="DatasetCompilationAttributes">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Additional compilation attributes on the dataset element</xs:documentation>
        </xs:annotation>
        <xs:attribute ref="iddisplay" use="optional"/>
        <xs:attribute name="shortName" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the short name for the dataset</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attributeGroup ref="ProvenanceCompilationAttributes"/>
        
        <xs:anyAttribute namespace="##other" processContents="skip"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="DatasetConceptCompilationAttributes">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Additional compilation attributes on the dataset element</xs:documentation>
        </xs:annotation>
        <xs:attribute ref="iddisplay" use="optional"/>
        <xs:attribute ref="refdisplay" use="optional"/>
        <xs:attribute name="shortName" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the short name for the concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attribute name="canonicalUri" type="xs:anyURI">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">HL7® FHIR® canonical URI. Logical URI to reference this StructureDefinition, logical model, value set, etc. (globally unique)</xs:documentation>
            <xs:documentation xml:lang="de-DE">HL7® FHIR® canonical URI. Logical URI to reference this StructureDefinition, logical model, value set, etc. (globally unique)</xs:documentation>
            <xs:documentation xml:lang="nl-NL">HL7® FHIR® kanonieke URI. Logische URI om te verwijzen naar deze StructureDefinition, dit logisch model, waardelijst, etc. (wereldwijd uniek)</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="iddisplay" type="xs:string">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the calculated display name for the value in @id</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="refdisplay" type="xs:string">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the calculated display name for the value in @ref</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    
    <xs:attributeGroup name="InheritCompilationAttributes">
        <!-- prefix="naw-" datasetId="2.16.840.1.113883.2.4.3.11.60.101.1.1" datasetEffectiveDate="2013-03-25T14:13:00" iType="group" iStatusCode="final" iEffectiveDate="2013-03-25T21:46:30" refdisplay="naw-dataelement-10000" -->
        <xs:attribute name="prefix" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the project prefix for the original concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="datasetId" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the dataset id for the original concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="datasetEffectiveDate" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the dataset effectiveDate for the inherited concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="iType" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the type for the original concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="iStatusCode" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the statusCode for the inherited concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="iEffectiveDate" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the effectiveDate for the inherited concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="iVersionLabel" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the versionLabel for the inherited concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="iExpirationDate" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the expirationDate for the inherited concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="originalId" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the concept id for the original concept, if the inherited concept was itself an inheriting/containing concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="originalStatusCode" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the concept statusCode for the original concept, if the inherited concept was itself an inheriting/containing concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="originalEffectiveDate" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the concept effectiveDate for the original concept, if the inherited concept was itself an inheriting/containing concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="originalVersionLabel" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the concept versionLabel for the original concept, if the inherited concept was itself an inheriting/containing concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="originalExpirationDate" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the concept expirationDate for the original concept, if the inherited concept was itself an inheriting/containing concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute ref="refdisplay" use="optional"/>
    </xs:attributeGroup>
    <xs:group name="DatasetConceptCompilationImplementation">
        <xs:sequence>
            <xs:element name="implementation" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the implementation specific info (TODO: explain in more detail)</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:any processContents="skip" namespace="##any" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:anyAttribute processContents="skip" namespace="##any"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:group name="DatasetConceptCompilationTerminologyAssociation">
        <xs:sequence>
            <xs:element ref="terminologyAssociation" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the copied terminology association from the terminology section applicable for this concept (TODO: explain in more detail)</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:group name="DatasetConceptCompilationIdentifierAssociation">
        <xs:sequence>
            <xs:element ref="identifierAssociation" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the copied identifier association from the ids section applicable for this concept (TODO: explain in more detail)</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:group name="DatasetConceptCompilationValueSet">
        <xs:sequence>
            <xs:element name="valueSet" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the enahanced value set bound to this concept (TODO: explain in more detail)</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:any processContents="skip" namespace="##any" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:anyAttribute processContents="skip" namespace="##any"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:group name="ValueSetCompilationSourceCodeSystem">
        <xs:sequence>
            <xs:element name="sourceCodeSystem" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains display names for code systems as an optimalization aid in the publication process</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:any processContents="skip" namespace="##any" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:anyAttribute processContents="skip" namespace="##any"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:attributeGroup name="ValueSetCompilationAttributes">
        <xs:attributeGroup ref="ProvenanceCompilationAttributes"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="CodeSystemCompilationAttributes">
        <xs:attributeGroup ref="ProvenanceCompilationAttributes"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="TemplateCompilationAttributes">
        <xs:attributeGroup ref="ProvenanceCompilationAttributes"/>
        
        <xs:anyAttribute namespace="##other" processContents="skip"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="TerminologyAssociationCompilationAttributes">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Additional compilation attributes on the terminologyAssociation element</xs:documentation>
        </xs:annotation>
        <xs:attribute name="valueSetName" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the the displayName of the value set if available else the name</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="IdentifierAssociationCompilationAttributes">
        <xs:attribute ref="refdisplay"/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
    </xs:attributeGroup>
    <!-- =================================== -->
</xs:schema>